<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[runtime之NSMutableArray安全]]></title>
      <url>http://yoursite.com/2016/06/25/runtime%E4%B9%8BNSMutableArray%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>昨天的<strong><a href="http://www.masyang.com/2016/01/22/runtime之NSArray、NSDictionary安全/" target="_blank" rel="external">博文:runtime之NSArray安全</a></strong>已经介绍了有关通过<font color="red"> Swizzing </font>使NSArray安全的操作,那么今天我们来谈一下相对繁琐的使用Swizzing让NSMutableArray安全的操作.<small>PS:文笔不行,望海涵</small></p>
   <a id="more"></a>  
<p><strong><a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo地址 : https://github.com/OneHalfTooth/Runtime_Safe</a></strong></p>
<h2 id="用到的方法"><a href="#用到的方法" class="headerlink" title="用到的方法"></a>用到的方法</h2><font color="green"><br>//得到类的实例方法的实现 返回值为Method类型</font><br><strong>1、</strong> class_getInstanceMethod(Class cls, SEL name)<br><br><font color="green"> //得到类的类方法的实现 返回值为Method类型</font><br><strong>2、</strong> class_getClassMethod(Class cls, SEL name)<br><br><font color="green"> //交换方法m1 和方法m2的实现</font><br><strong>3、</strong> method_exchangeImplementations(Method m1, Method m2)<br><br><font color="green"> /*就像Application有生命周期回调方法一样,在Objective-C的类被加载和初始化的时候的回调方法,可以使用 Method Swizzing 以保证 Method Swizzing成功*/</font><br><strong>4、</strong> + (void)load<br>

<h2 id="要解决的痛点"><a href="#要解决的痛点" class="headerlink" title="要解决的痛点"></a>要解决的痛点</h2><p><strong>NSMutableArray * array = [[NSMutableArray alloc]init];</strong></p>
<p><font color="green">/* array追加一个nil对象*/</font><br><strong>1.</strong> [array addObject:nil];</p>
<p><font color="green">/* array追加一个nil的数组*/</font><br><strong>2.</strong> [array addObjectsFromArray:nil];</p>
<p><font color="green">/* array插入一个nil*/</font><br><strong>3.</strong> [array insertObject:nil atIndex:0];</p>
<p><font color="green">/* 在array大于array.count 位置插入一个对象*/</font><br><strong>4.</strong> [array insertObject:@”key” atIndex:9999];</p>
<p><font color="green">/* array移除一个nil的对象*/</font><br><strong>5.</strong> [array removeObject:nil];</p>
<p><font color="green">/* 移除array大于array.count 位置的对象*/</font><br><strong>6.</strong> [array removeObjectAtIndex:9999];</p>
<p><strong>以上情况基本都能导致应用crash,现在我们就来彻底解决这种crash</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>使用runtime <font color="red"> Method Swizzing </font>替换上述几个方法</li>
<li>让程序每次调用的以上几个方法之前,首先调用我们自定义的方法</li>
<li>在我们自定义的方法中校验参数合法性等,以保障之后调用系统的方法不会产生<font color="red">crash</font></li>
<li>执行完参数合法性判断之后,调用系统的方法,以达到预期调用目的</li>
</ol>
<h5 id="要点"><a href="#要点" class="headerlink" title="要点 "></a><font color="red">要点 </font></h5><ol>
<li>在编译过程中NSMutableArray对象的Class 应该是<font color="red"><strong>__NSArrayM</strong> </font><small>(注意是双下划线)</small></li>
<li>必须保证在NSMutableArray这个对象初始化,或者使用之前已经完成<font color="red"> <strong>Method Swizzing</strong> </font>替换</li>
<li>arr[0] = @”value” 和 [array addObject:@”value”] 或者 [array insertObject:@”value” atIndex:0]<font color="red"><strong>调用的系统方法是不同的</strong></font>.</li>
</ol>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="一、使用Method-Swizzing替换上述几个方法"><a href="#一、使用Method-Swizzing替换上述几个方法" class="headerlink" title="一、使用Method Swizzing替换上述几个方法"></a><small>一、使用<font color="red">Method Swizzing</font>替换上述几个方法</small></h6><p>自定义上述的几个方法,用来替换系统的几个方法<small>(要求:参数类型,返回值最好保持一致)<font color="red">看完这几个方法,可能有些许疑惑,稍后为你解答</font></small>.</p>
<pre><code>//用来替换removeObject:方法
-(void)customRemoveObject:(id)anObject{
    if (anObject) {/*参数合法性判断*/
        //调用系统的RemoveObject:方法
        [self customRemoveObject:anObject];
    }else{
        NSLog(@&quot;数组移除了一个nil的元素&quot;);
    }
}
//替换removeObjectAtIndex:方法
-(void)customRemoveObjectAtIndex:(NSUInteger)index{
    if (index &lt; self.count) {/*参数合法性判断*/
        //调用系统的RemoveObjectAtIndex:方法
        [self customRemoveObjectAtIndex:index];
    }else{
        NSLog(@&quot;数组越界操作,下标为%lu&quot;,index);
    }
}
//用来替换同类的 arr[0] = @&quot;value&quot;这种写法
-(void)msySetObject:(id)obj atIndexedSubscript:(NSUInteger)idx{
    if (obj) {/*参数合法性判断*/
        //调用系统的setObject:atIndexedSubscript:方法
        [self msySetObject:obj atIndexedSubscript:idx];
    }else{
        NSLog(@&quot;数组赋值为nil：%s传了个空值\n&quot;,__func__);
    }
}
- (void)msyInsertObject:(id)anObject atIndex:(NSUInteger)index{
    if (anObject &amp;&amp; index &lt;= self.count) {/*参数合法性判断*/
        //调用系统的insertObject:atIndex:方法
        [self msyInsertObject:anObject atIndex:index];
    }else{
        NSLog(@&quot;数组赋值为nil：%s传了个空值\n&quot;,__func__);
    }
}
- (void)msyAddObject:(id)obj{
    if (obj) {/*参数合法性判断*/
    //调用系统的ObjectAtIndex:方法
        [self msyAddObject:obj];
    }else{
        NSLog(@&quot;数组赋值为nil：%s传了个空值\n&quot;,__func__);
    }
}
- (id)custmeObjectAtIndex:(NSInteger)index{
    if (index &gt;= self.count) {/*参数合法性判断*/
        return nil;
    }
    //调用系统的ObjectAtIndex:方法
    return [self custmeObjectAtIndex:index];
}
</code></pre><p><strong>至此 用来替换系统方法的方法已经准备好了</strong><br><br><strong>然后我们要用自己的方法去替换系统的方法的实现</strong></p>
<pre><code>//必须包含运行时的库
#import &lt;objc/runtime.h&gt;

//在load方法里边交换自定义方法与系统方法的实现,
//因为这个方法会在类初始化之前执行,这样我们就可以保证系统方法的实现已经被我们替换
+(void)load{

//先获取NSMutableArray的Class @&quot;__NSArrayM&quot; 为双下划线
Class arrayM = NSClassFromString(@&quot;__NSArrayM&quot;);

//获取实例方法addObject:的Method
Method methodSuper = class_getInstanceMethod(arrayM, @selector(addObject:));
//获取自己定义的实例方法msyAddObject:的Method
Method method = class_getInstanceMethod(arrayM, @selector(msyAddObject:));
//交换两个方法的实现
method_exchangeImplementations(methodSuper, method);

//一下注释同上
Method methodSuperInsert = class_getInstanceMethod(arrayM, @selector(insertObject:atIndex:));
Method methodInsert = class_getInstanceMethod(arrayM, @selector(msyInsertObject:atIndex:));
method_exchangeImplementations(methodSuperInsert, methodInsert);

Method methodSuperSetObj = class_getInstanceMethod(arrayM, @selector(setObject:atIndexedSubscript:));
Method methodSetObj = class_getInstanceMethod(arrayM, @selector(msySetObject:atIndexedSubscript:));
method_exchangeImplementations(methodSetObj, methodSuperSetObj);

Method methodSuperRemove = class_getInstanceMethod(arrayM, @selector(removeObjectAtIndex:));
Method methodRemove = class_getInstanceMethod(arrayM, @selector(customRemoveObjectAtIndex:));
method_exchangeImplementations(methodSuperRemove, methodRemove);

Method methodSuperRemoveObj = class_getInstanceMethod(arrayM, @selector(removeObject:));
Method methodRemoveObj = class_getInstanceMethod(arrayM, @selector(customRemoveObject:));
method_exchangeImplementations(methodSuperRemoveObj, methodRemoveObj);

Method objectAtIndex = class_getInstanceMethod(arrayM, @selector(objectAtIndex:));
Method customeObjectAtIndex = class_getInstanceMethod(arrayM, @selector(custmeObjectAtIndex:));
method_exchangeImplementations(objectAtIndex, customeObjectAtIndex);
</code></pre><p>}</p>
<h6 id="二、创建一个NSMutableArray-的分类-将上述代码放入"><a href="#二、创建一个NSMutableArray-的分类-将上述代码放入" class="headerlink" title="二、创建一个NSMutableArray 的分类,将上述代码放入"></a><small>二、创建一个NSMutableArray 的分类,将上述代码放入</small></h6><p><img src="/img/NSMutableArraySafeImage.png"><br>😆😆😆😆😆😆<br><br>然后你就可以愉快的这样了</p>
<pre><code>NSMutableArray * array = [[NSMutableArray alloc]init];
[array addObject:nil];
[array addObjectsFromArray:nil];
[array insertObject:nil atIndex:0];
[array insertObject:@&quot;value&quot; atIndex:9999];
[array insertObjects:nil atIndexes:0];
[array removeObject:nil];
[array removeObjectAtIndex:9999];
[array removeObjectsInArray:nil];
</code></pre><p>并且你会神奇的发现他没有crash</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ol>
<li><strong>上述代码中出现了自己调用自己</strong></li>
</ol>
<pre><code>-(void)msyAddObject:(id)obj{
        if (obj) {/*参数合法性判断*/
          [self msyAddObject:obj];//调用系统的addObject:方法
      }else{
           NSLog(@&quot;数组赋值为nil：%s传了个空值\n&quot;,__func__);
      }
 }
</code></pre><p><small>如果你细心肯定会发现第3行代码出现了自己调用自己的情况,但是我在后边的注释确是<font color="green">//调用系统的addObject:方法</font>.<br>正常的说,这种情况应该是一个死循环,但是你不要忘了现在我们使用了Method Swizzing,我们已经用runtime 将<font color="red">msyAddObject:方法的方法的<big><strong>实现</strong></big>与addObject:的<strong><big>实现</big></strong>交换</font><br>我们交换的只是实现,只是方法名还是没有变,所以写在msyAddObject:的代码,经过我们的<font color="red">method_exchangeImplementations(Method m1,Method m2)</font>之后已经不是写在msyAddObject:里边,而是在系统的addObject:中,所以我们在msyAddObject:调用msyAddObject:的时候,其实是调用系统addObject:的实现,所以并不是自己调用自己😄,也就不会出现死循环了</small></p>
<ol>
<li><strong>或许你发现本人在创建分类的时候出现了一个#ifdef DEBUG #else #endif</strong></li>
</ol>
<p><small>这是条件编译,表示在debug模式下 会编译#ifdef 和 #else之间的代码,在release模式会编译#else #endif之间的代码,这样做的目的是为了在编写代码的时候能够尽多的发现问题,而在上线的时候尽多的避免问题</small></p>
<h2 id="表达能力很差-可能有些东西没说清楚-如有需要可以深入沟通"><a href="#表达能力很差-可能有些东西没说清楚-如有需要可以深入沟通" class="headerlink" title="表达能力很差,可能有些东西没说清楚,如有需要可以深入沟通."></a>表达能力很差,可能有些东西没说清楚,如有需要可以深入沟通.</h2><p><strong><a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo地址 : https://github.com/OneHalfTooth/Runtime_Safe</a></strong><br><br><strong>个人邮箱:mayang_email@sina.cn</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime之NSMutableDictionary安全]]></title>
      <url>http://yoursite.com/2016/06/24/runtime%E4%B9%8BNSMutableDictionary%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>众所周知,apple要求我们在NSMutableDictionary中不能插入nil,所以我们一旦出现这种操作就会crash,但是我们不能保证完全不会出现这种操作,除非使用大量if去做参数合法性判断</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary * testDic = [[NSMutableDictionary alloc]init];</div><div class="line">[testDic setObject:nil forKey:@&quot;key&quot;];</div><div class="line">[testDic removeObjectForKey:nil];</div></pre></td></tr></table></figure>
<p><strong>比如以上两种情况,肯定毫不犹豫的就crash</strong><br><br><strong>注意:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testDic[&quot;key&quot;] = nil;</div></pre></td></tr></table></figure></p>
<p>是不会崩溃的,因为系统默认做了空值检查,推荐以后都用这种写法.</p>
<h5 id="我们现在要做的如果就是你一不小心出现以上操作-程序不会crash"><a href="#我们现在要做的如果就是你一不小心出现以上操作-程序不会crash" class="headerlink" title="我们现在要做的如果就是你一不小心出现以上操作,程序不会crash"></a>我们现在要做的如果就是你一不小心出现以上操作,程序不会crash</h5><p><strong>我们要用到这么几个方法</strong></p>
<font color="green"><br>//得到类的实例方法的实现 返回值为Method类型</font><br><strong>1、</strong> class_getInstanceMethod(Class cls, SEL name)<br><br><font color="green"> //得到类的类方法的实现 返回值为Method类型</font><br><strong>2、</strong> class_getClassMethod(Class cls, SEL name)<br><br><font color="green"> //交换方法m1 和方法m2的实现</font><br><strong>3、</strong> method_exchangeImplementations(Method m1, Method m2)<br><br><font color="green"> /*就像Application有生命周期回调方法一样,在Objective-C的类被加载和初始化的时候的回调方法,可以使用 Method Swizzing 以保证 Method Swizzing成功*/</font><br><strong>4、</strong> + (void)load<br>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>使用runtime <font color="red"> Method Swizzing </font>替换上述几个方法</li>
<li>让程序每次调用的以上几个方法之前,首先调用我们自定义的方法</li>
<li>在我们自定义的方法中校验参数合法性等,以保障之后调用系统的方法不会产生<font color="red">crash</font></li>
<li>执行完参数合法性判断之后,调用系统的方法,以达到预期调用目的</li>
</ol>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点 "></a><font color="red">要点 </font></h3><ol>
<li>在编译过程中NSMutableArray对象的Class 应该是<font color="red"><strong>__NSDictionaryM</strong> </font><small>(注意是双下划线)</small></li>
<li>必须保证在NSMutableArray这个对象初始化,或者使用之前已经完成<font color="red"> <strong>Method Swizzing</strong> </font>替换</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p> <strong>首先我们来完成前三步</strong></p>
<pre><code> -(void)customSetObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey{
    if (anObject) {
       [self customSetObject:anObject forKey:aKey];
    }else{
       NSLog(@&quot;setObject了一个空，key为%@&quot;,aKey);
   }
}
-(void)customRemoveObjectForKey:(id)aKey{
    if (aKey) {
        [self customRemoveObjectForKey:aKey];
    }else{
       NSLog(@&quot;remove了一个空，key为%@&quot;,aKey);
    }
}
</code></pre><p><strong>至此 用来替换系统方法的方法已经准备好了</strong><br><br><strong>然后我们要用自己的方法去替换系统的方法的实现</strong></p>
<pre><code>+(void)load{
    Class dictCls = NSClassFromString(@&quot;__NSDictionaryM&quot;);

    Method methodSetObjSuper = class_getInstanceMethod(dictCls, NSSelectorFromString(@&quot;setObject:forKey:&quot;));
    Method methodSetObj = class_getInstanceMethod(dictCls, @selector(customSetObject:forKey:));
    method_exchangeImplementations(methodSetObj, methodSetObjSuper);

    Method methodSuperRemoveKey = class_getInstanceMethod(dictCls, @selector(removeObjectForKey:));
    Method methodRemoveKey = class_getInstanceMethod(dictCls, @selector(customRemoveObjectForKey:));
    method_exchangeImplementations(methodRemoveKey, methodSuperRemoveKey);
}
</code></pre><p><strong>需要注意的是</strong> NSMutableDictionary在编译的时候是__NSDictionaryM类(双下划线)</p>
<h3 id="然后我们需要创建一个NSMutableDictionary的分类将代码放进去"><a href="#然后我们需要创建一个NSMutableDictionary的分类将代码放进去" class="headerlink" title="然后我们需要创建一个NSMutableDictionary的分类将代码放进去"></a>然后我们需要创建一个NSMutableDictionary的分类将代码放进去</h3><p><strong>比如</strong><br><img src="/img/NSMutableDictionary.png"><br>然后你就可以尝试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary * testDic = [[NSMutableDictionary alloc]init];</div><div class="line">[testDic setObject:nil forKey:@&quot;key&quot;];</div><div class="line">[testDic removeObjectForKey:nil];</div></pre></td></tr></table></figure></p>
<p>然后你就会发现程序并没有崩溃,其实原理非常简单.</p>
<ol>
<li>我们在程序开始运行的时候已经将系统的方法实现替换成自己的,同时也将自己的方法实现替换成系统的,所以如果想执行系统的方法,其实会先执行我们自定义的方法实现,我们在自己的方法实现中做参数合法性判断,如果不会引起系统崩溃那我们就去调用系统方法,会引起的话就不调用,所以肯定不会崩溃.</li>
</ol>
<h2 id="demo-https-github-com-OneHalfTooth-Runtime-Safe"><a href="#demo-https-github-com-OneHalfTooth-Runtime-Safe" class="headerlink" title="demo(https://github.com/OneHalfTooth/Runtime_Safe"></a><a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo(https://github.com/OneHalfTooth/Runtime_Safe</a></h2><p><strong>个人邮箱:mayang_email@sina.cn</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime之NSDictionary安全]]></title>
      <url>http://yoursite.com/2016/06/23/runtime%E4%B9%8BNSDictionary%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>昨天已经写文章探讨<a href="http://www.masyang.com/2016/01/23/runtime之NSMutableArray安全/" target="_blank" rel="external">runtime之NSDictionary安全</a>那么今天我们就来探讨一下怎样让NSDictionary安全,使NSDictionary操作nil而不crash<br><a id="more"></a></p>
<h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><p> 在NSDictionary中不管是key还是value是不能出现nil的,然而我们在做任何有关NSDictionary操作的时候我们都要考虑这个问题,参数会不会是nil,会不会引起崩溃.然后我们为了程序的健壮性,就写了一堆if,来校验参数合法性.来保证程序不会再运行的时候crash.<br> 现在我们用runtime,从根本上去预防NSDictionary插入nil崩溃这种问题<br><br> <strong>相对于NSMutableDictionary来说NSDictionary我们需要解决的问题就要少的多</strong><br><br>比如<font color="red"><strong>NSDictionary * test = @{@”crash”: nil, @”key”: @”value”};</strong></font><br><br><strong>在这只演示替换一个方法,如有更多需要请看<a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo:https://github.com/OneHalfTooth/Runtime_Safe</a></strong></p>
<h2 id="要使用的方法"><a href="#要使用的方法" class="headerlink" title="要使用的方法"></a>要使用的方法</h2><font color="green"><br>//得到类的实例方法的实现 返回值为Method类型</font><br><strong>1、</strong> class_getInstanceMethod(Class cls, SEL name)<br><br><font color="green"> //得到类的类方法的实现 返回值为Method类型</font><br><strong>2、</strong> class_getClassMethod(Class cls, SEL name)<br><br><font color="green"> //交换方法m1 和方法m2的实现</font><br><strong>3、</strong> method_exchangeImplementations(Method m1, Method m2)<br><br><font color="green"> /*就像Application有生命周期回调方法一样,在Objective-C的类被加载和初始化的时候的回调方法,可以使用 Method Swizzing 以保证 Method Swizzing成功*/</font><br><strong>4、</strong> + (void)load<br>

<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><ol>
<li>使用自定义的方法,将系统的方法替换掉</li>
<li>在自定义方法中做参数合法性判断</li>
<li>调用系统的方法以达到预期目的</li>
<li>交换自定义方法与系统方法的实现</li>
</ol>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol>
<li>实现解决思路的前三步<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+(instancetype)customDictionaryWithObjects:(const id [])objects forKeys:(const id &lt;NSCopying&gt; [])keys count:(NSUInteger)cnt &#123;</div><div class="line">	id nObjects[cnt];</div><div class="line">	id nKeys[cnt];</div><div class="line">	int i=0, j=0;</div><div class="line">	for (; i&lt;cnt &amp;&amp; j&lt;cnt; i++) &#123;</div><div class="line">		if (objects[i] &amp;&amp; keys[i]) &#123;</div><div class="line">			nObjects[j] = objects[i];</div><div class="line">			nKeys[j] = keys[i];</div><div class="line">			j++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return [self customDictionaryWithObjects:nObjects forKeys:nKeys count:j];//调用系统的方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>对objects进行空值过滤，如果是空值的话，不插入字典。达到参数合法性判断的目的</strong></p>
<ol>
<li>替换系统的方法</li>
</ol>
<pre><code>+(void)load{
    Method originalMethod = class_getClassMethod(self, @selector(dictionaryWithObjects:forKeys:count:));
    Method swizzledMethod = class_getClassMethod(self, @selector(customDictionaryWithObjects:forKeys:count:));
    method_exchangeImplementations(originalMethod, swizzledMethod);
}
</code></pre><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ol>
<li><p><strong>为什么我们要在load中执行Method Swizzing</strong><br><br> 因为这个方法会在类初始化之前执行,这样我们就可以保证系统方法的实现已经被我们替换</p>
</li>
<li><p><strong>以上代码中出现自己调用自己的死循环</strong><br> 如果你细心肯定会发现上边自定义方法里边出现了自己调用自己的情况,但是我在后边的注释确是//调用系统的方法. 正常的说,这种情况应该是一个死循环,但是你不要忘了现在我们使用了Method Swizzing,我们已经用runtime 将自定义方法的方法的实现与系统的实现交换 我们交换的只是实现,只是方法名还是没有变</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime之NSArray安全]]></title>
      <url>http://yoursite.com/2016/06/22/runtime%E4%B9%8BNSArray%E3%80%81NSDictionary%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>看了<a href="http://www.cnblogs.com/muyushifang07/p/5737564.html" target="_blank" rel="external"><strong>沐雨十方07</strong></a>的这篇博客之后，我决定将自己开发过程中用的一个小技巧分享一下,以方便各种猿的程序开发。</p>
   <a id="more"></a>  
<p>众所周知，在apple的淫威下NSArray,NSDictionary,NSMutableArray,NSMutableDictionary是不不能出现有关nil的操作,一旦操作就会出现<strong>crash</strong>的后果,如果我们要避免这种<strong>crash</strong>那么就要增加许多if,现在我们来利用runtime彻底解决这个问题.<br><br><br><a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo地址 : https://github.com/OneHalfTooth/Runtime_Safe</a></p>
<p><strong>首先我们可能用到几个函数</strong>（需要包含<font color="red">运行时库</font>）<br><br> <font color="red">class_getInstanceMethod(Class cls, SEL name):得到类的实例方法</font></p>
  <font color="red">class_getClassMethod(Class cls, SEL name):得到类的类方法</font>

<p>  <font color="red"> method_exchangeImplementations(Method m1, Method m2) : 交换方法m1 和方法m2的实现</font></p>
<h2 id="runtime之NSArray的nil操作"><a href="#runtime之NSArray的nil操作" class="headerlink" title="runtime之NSArray的nil操作"></a>runtime之NSArray的nil操作</h2><p>码代码的过程中我们一不小心可能就会出现类似于这种情况</p>
<pre><code>NSArray * temp = @[@&quot;0&quot;,@&quot;1&quot;,@&quot;2&quot;];
NSString * str = [temp objectAtIndex:4];
</code></pre><p>后果就是<strong>crash</strong><br><br>但是我们发现大牛们写代码的时候通常<strong>很少出现对数组越界</strong>的异常处理情况,到底是什么原因呢，其实我也不知道😝<br><br>而我是使用runtime的黑魔法来解决这种情况的,请看源码<br></p>
<pre><code>- (id)custmeObjectAtIndex:(NSInteger)index{
if (index &gt;= self.count) {
    return nil;
}
//或许你对这里有个疑问，稍后解答
return [self custmeObjectAtIndex:index];
}
</code></pre><p>首先我声明一个方法,因为我要用黑魔法<font color="red">（Method Swizzling）</font>将系统的<strong>objectAtIndex:</strong>方法实现给替换掉,这样做的目的是在<strong>NSArray调用objectAtIndex:</strong>方法的时候，首先调用<strong>(custmeObjectAtIndex:)</strong>本人定义好的方法,然后在custmeObjectAtIndex:这个方法中去判断参数合法性，再做下一步打算.<br><br>然后我们开始使用<font color="red">（Method Swizzling）</font>将系统<strong>objectAtIndex:</strong>的实现和<strong>(custmeObjectAtIndex:)</strong>的实现进行交换</p>
<pre><code>//NSArray 在编译的时候名字并不是NSarray而是__NSArray0
Class arrayM = NSClassFromString(@&quot;__NSArray0&quot;);

//获取到系统objectAtIndex:
Method objectAtIndex = class_getInstanceMethod(arrayM, @selector(objectAtIndex:));

//获取自定义的custmeObjectAtIndex:
Method customeObjectAtIndex = class_getInstanceMethod(arrayM, @selector(custmeObjectAtIndex:));

//交换两个方法的实现
method_exchangeImplementations(objectAtIndex, customeObjectAtIndex);
</code></pre><p>至此,我们常见的数组越界crash已经被解决了,但是你是不是已经蒙圈了😁,为什么在<strong>- (id)custmeObjectAtIndex:(NSInteger)index</strong>方法中出现了 <strong>[self custmeObjectAtIndex:index];</strong>自己调用自己这种情况呢,前边我已经说了是交换两个方法的实现,所以说两个方法的内容<strong>(简单的说就是方法里边的代码)</strong>已经被交换,所以[self custmeObjectAtIndex:index]这句代码调用的系统objectAtIndex:的实现，所以并不是自己调用自己</p>
<p><strong>我们还需要注意一点,我们必须保证任何时间,只要是有关NSArray的操作,我们的runtime已经执行过了<br>所以我们要在+ (void)load方法去执行这个Swizzing</strong></p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import &lt;objc/runtime.h&gt;

//分类
@implementation NSArray (Safe)
//初始化的时候会被执行一次
+ (void)load {

Method originalMethod = class_getClassMethod(self, @selector(arrayWithObjects:count:));
Method swizzledMethod = class_getClassMethod(self, @selector(customArrayWithObjects:count:));
method_exchangeImplementations(originalMethod, swizzledMethod);

Class arrayM = NSClassFromString(@&quot;__NSArray0&quot;);
Method objectAtIndex = class_getInstanceMethod(arrayM, @selector(objectAtIndex:));
Method customeObjectAtIndex = class_getInstanceMethod(arrayM, @selector(custmeObjectAtIndex:));
method_exchangeImplementations(objectAtIndex, customeObjectAtIndex);

}


+ (instancetype)customArrayWithObjects:(const id [])objects count:(NSUInteger)cnt {

    id nObjects[cnt];
    int i=0, j=0;
    for (; i&lt;cnt &amp;&amp; j&lt;cnt; i++) {
        if (objects[i]) {
            nObjects[j] = objects[i];
            j++;
        }
    }
    return [self customArrayWithObjects:nObjects count:j];
}

- (id)custmeObjectAtIndex:(NSInteger)index{

    if (index &gt;= self.count) {
        return nil;
    }
return [self custmeObjectAtIndex:index];
}
</code></pre><p><strong>至此一个关于NSArray的安全类已经结束,当然这只是一部分,更详细请<a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">查看demo:https://github.com/OneHalfTooth/Runtime_Safe</a></strong><br><br><strong>欢迎提出您的宝贵意见:<font color="blue">mayang_email@sina.cn</font></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识ReactiveCocoa]]></title>
      <url>http://yoursite.com/2016/05/11/%E5%88%9D%E8%AF%86ReactiveCocoa/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>(简称为RAC), 是由Github开源的一个应用于iOS和OS开发的新框架, RAC具有函数式编程和响应式编程的特性, 通过这篇文章对RAC有一个简单的了解。</p>
<a id="more"></a>
<h3 id="1-如何导入ReactiveCocoa框架"><a href="#1-如何导入ReactiveCocoa框架" class="headerlink" title="1.如何导入ReactiveCocoa框架"></a>1.如何导入ReactiveCocoa框架</h3><p>通常都会使用CocoaPods（用于管理第三方框架的插件）帮助我们导入。PS:<a href="http://code4app.com/article/cocoapods-install-usage" target="_blank" rel="external">CocoaPods教程</a><br><strong>注意:</strong> 2.5版本以后不支持iOS7</p>
<h3 id="2-ReactiveCocoa常见类"><a href="#2-ReactiveCocoa常见类" class="headerlink" title="2.ReactiveCocoa常见类"></a>2.ReactiveCocoa常见类</h3><p>　　学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类RACSiganl,搞定这个类就能用ReactiveCocoa开发了。<br><strong>RACSiganl：</strong> 信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
<ul>
<li>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</li>
<li>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</li>
<li>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</li>
<li><code>RACSiganl</code>简单使用:</li>
</ul>
<pre><code>
    // RACSignal使用步骤：
    // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id<racsubscriber> subscriber))didSubscribe
    // 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
    // 3.发送信号 - (void)sendNext:(id)value

    // RACSignal底层实现：
    // 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。
    // 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock
    // 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。
    // 2.1 subscribeNext内部会调用siganl的didSubscribe
    // 3.siganl的didSubscribe中调用[subscriber sendNext:@1];
    // 3.1 sendNext底层其实就是执行subscriber的nextBlock

    // 1.创建信号
    RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
        // block调用时刻：每当有订阅者订阅信号，就会调用block。
        // 2.发送信号
        [subscriber sendNext:@1];
        // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。
        [subscriber sendCompleted];
        return [RACDisposable disposableWithBlock:^{
            // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。
            // 执行完Block后，当前信号就不在被订阅了。
            NSLog(@"信号被销毁");
        }];
    }];
    // 3.订阅信号,才会激活信号.
    [siganl subscribeNext:^(id x) {
        // block调用时刻：每当有信号发出数据，就会调用block.
        NSLog(@"接收到数据:%@",x);
    }];</racsubscriber></racsubscriber></code></pre>


<p><strong>RACSubscriber</strong>: 表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。<br><strong>RACDisposable</strong>: 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p>
<ul>
<li><code>使用场景</code>:不想监听某个信号时，可以通过它主动取消订阅信号。</li>
</ul>
<p><strong>RACSubject</strong>:信号提供者，自己可以充当信号，又能发送信号。</p>
<ul>
<li><code>使用场景</code>:通常用来代替代理，有了它，就不必要定义代理了。</li>
</ul>
<p><strong>RACReplaySubjec</strong>:重复提供信号类，RACSubject的子类。</p>
<ul>
<li><code>RACReplaySubject</code>与<code>RACSubject</code>区别:<br>　　　&gt; RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li>
<li><code>使用场景一</code>:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>
<li><code>使用场景二</code>:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。</li>
<li><code>RACSubject</code>和<code>RACReplaySubject</code>简单使用:</li>
</ul>
<pre><code>
// RACSubject使用步骤
    // 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。
    // 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
    // 3.发送信号 sendNext:(id)value

    // RACSubject:底层实现和RACSignal不一样。
    // 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。
    // 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。

    // 1.创建信号
    RACSubject *subject = [RACSubject subject];

    // 2.订阅信号
    [subject subscribeNext:^(id x) {
        // block调用时刻：当信号发出新值，就会调用.
        NSLog(@"第一个订阅者%@",x);
    }];
    [subject subscribeNext:^(id x) {
        // block调用时刻：当信号发出新值，就会调用.
        NSLog(@"第二个订阅者%@",x);
    }];

    // 3.发送信号
    [subject sendNext:@"1"];


    // RACReplaySubject使用步骤:
    // 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。
    // 2.可以先订阅信号，也可以先发送信号。
    // 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
    // 2.2 发送信号 sendNext:(id)value

    // RACReplaySubject:底层实现和RACSubject不一样。
    // 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
    // 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock

    // 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。
    // 也就是先保存值，在订阅值。

    // 1.创建信号
    RACReplaySubject *replaySubject = [RACReplaySubject subject];

    // 2.发送信号
    [replaySubject sendNext:@1];
    [replaySubject sendNext:@2];

    // 3.订阅信号
    [replaySubject subscribeNext:^(id x) {

        NSLog(@"第一个订阅者接收到的数据%@",x);
    }];

    // 订阅信号
    [replaySubject subscribeNext:^(id x) {

        NSLog(@"第二个订阅者接收到的数据%@",x);
    }];
</code></pre>

<ul>
<li><code>RACSubject</code>替换代理</li>
</ul>
<pre><code>
// 需求:
    // 1.给当前控制器添加一个按钮，modal到另一个控制器界面
    // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器

步骤一：在第二个控制器.h，添加一个RACSubject代替代理。
@interface TwoViewController : UIViewController

@property (nonatomic, strong) RACSubject *delegateSignal;

@end

步骤二：监听第二个控制器按钮点击
@implementation TwoViewController
- (IBAction)notice:(id)sender {
    // 通知第一个控制器，告诉它，按钮被点了

     // 通知代理
     // 判断代理信号是否有值
    if (self.delegateSignal) {
        // 有值，才需要通知
        [self.delegateSignal sendNext:nil];
    }
}
@end

步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.
@implementation OneViewController
- (IBAction)btnClick:(id)sender {

    // 创建第二个控制器
    TwoViewController *twoVc = [[TwoViewController alloc] init];

    // 设置代理信号
    twoVc.delegateSignal = [RACSubject subject];

    // 订阅代理信号
    [twoVc.delegateSignal subscribeNext:^(id x) {

        NSLog(@"点击了通知按钮");
    }];

    // 跳转到第二个控制器
    [self presentViewController:twoVc animated:YES completion:nil];

}
@end
</code></pre>

<ul>
<li><code>RACTuple</code>:元组类,类似NSArray,用来包装值.</li>
<li><code>RACSequence</code>:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。</li>
<li><code>使用场景</code>：1.字典转模型</li>
<li><code>RACSequence</code>和<code>RACTuple</code>简单使用</li>
</ul>
<pre><code>
// 1.遍历数组
    NSArray *numbers = @[@1,@2,@3,@4];

    // 这里其实是三步
    // 第一步: 把数组转换成集合RACSequence numbers.rac_sequence
    // 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal
    // 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。
    [numbers.rac_sequence.signal subscribeNext:^(id x) {

        NSLog(@"%@",x);
    }];


    // 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)
    NSDictionary *dict = @{@"name":@"xmg",@"age":@18};
    [dict.rac_sequence.signal subscribeNext:^(RACTuple *x) {

        // 解包元组，会把元组的值，按顺序给参数里面的变量赋值
        RACTupleUnpack(NSString *key,NSString *value) = x;

        // 相当于以下写法
//        NSString *key = x[0];
//        NSString *value = x[1];

        NSLog(@"%@ %@",key,value);

    }];


    // 3.字典转模型
    // 3.1 OC写法
    NSString *filePath = [[NSBundle mainBundle] pathForResource:@"flags.plist" ofType:nil];

    NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];

    NSMutableArray *items = [NSMutableArray array];

    for (NSDictionary *dict in dictArr) {
        FlagItem *item = [FlagItem flagWithDict:dict];
        [items addObject:item];
    }

    // 3.2 RAC写法
    NSString *filePath = [[NSBundle mainBundle] pathForResource:@"flags.plist" ofType:nil];

    NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];

    NSMutableArray *flags = [NSMutableArray array];

    _flags = flags;

    // rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。
    [dictArr.rac_sequence.signal subscribeNext:^(id x) {
        // 运用RAC遍历字典，x：字典

        FlagItem *item = [FlagItem flagWithDict:x];

        [flags addObject:item];

    }];

    NSLog(@"%@",  NSStringFromCGRect([UIScreen mainScreen].bounds));


    // 3.3 RAC高级写法:
    NSString *filePath = [[NSBundle mainBundle] pathForResource:@"flags.plist" ofType:nil];

    NSArray *dictArr = [NSArray arrayWithContentsOfFile:filePath];
    // map:映射的意思，目的：把原始值value映射成一个新值
    // array: 把集合转换成数组
    // 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。
    NSArray *flags = [[dictArr.rac_sequence map:^id(id value) {

        return [FlagItem flagWithDict:value];

    }] array];
</code></pre>

<ul>
<li><code>RACMulticastConnection</code>:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</li>
<li><code>使用注意</code>:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</li>
<li><code>RACMulticastConnection</code>简单使用:</li>
</ul>
<pre><code>
// RACMulticastConnection使用步骤:
    // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id<racsubscriber> subscriber))didSubscribe
    // 2.创建连接 RACMulticastConnection *connect = [signal publish];
    // 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]
    // 4.连接 [connect connect]

    // RACMulticastConnection底层原理:
    // 1.创建connect，connect.sourceSignal -> RACSignal(原始信号)  connect.signal -> RACSubject
    // 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。
    // 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject
    // 3.1.订阅原始信号，就会调用原始信号中的didSubscribe
    // 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext
    // 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。
    // 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock


    // 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。
    // 解决：使用RACMulticastConnection就能解决.

    // 1.创建请求信号
   RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {


        NSLog(@"发送请求");

        return nil;
    }];
    // 2.订阅信号
    [signal subscribeNext:^(id x) {

        NSLog(@"接收数据");

    }];
    // 2.订阅信号
    [signal subscribeNext:^(id x) {

        NSLog(@"接收数据");

    }];

    // 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求


    // RACMulticastConnection:解决重复请求问题
    // 1.创建信号
    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {


        NSLog(@"发送请求");
        [subscriber sendNext:@1];

        return nil;
    }];

    // 2.创建连接
    RACMulticastConnection *connect = [signal publish];

    // 3.订阅信号，
    // 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:
    [connect.signal subscribeNext:^(id x) {

        NSLog(@"订阅者一信号");

    }];

    [connect.signal subscribeNext:^(id x) {

        NSLog(@"订阅者二信号");

    }];

    // 4.连接,激活信号
    [connect connect];
</racsubscriber></racsubscriber></racsubscriber></code></pre>

<ul>
<li><code>RACCommand</code>:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</li>
<li><code>使用场景</code>:监听按钮点击，网络请求</li>
<li><code>RACCommand</code>简单使用</li>
</ul>
<pre><code>
// 一、RACCommand使用步骤:
    // 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock
    // 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值
    // 3.执行命令 - (RACSignal *)execute:(id)input

    // 二、RACCommand使用注意:
    // 1.signalBlock必须要返回一个信号，不能传nil.
    // 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];
    // 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。

    // 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。
    // 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。
    // 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。

    // 四、如何拿到RACCommand中返回信号发出的数据。
    // 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。
    // 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。

    // 五、监听当前命令是否正在执行executing

    // 六、使用场景,监听按钮点击，网络请求


    // 1.创建命令
    RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {


        NSLog(@"执行命令");

        // 创建空信号,必须返回信号
        //        return [RACSignal empty];

        // 2.创建信号,用来传递数据
        return [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {

            [subscriber sendNext:@"请求数据"];

            // 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。
            [subscriber sendCompleted];

            return nil;
        }];

    }];

    // 强引用命令，不要被销毁，否则接收不到数据
    _conmmand = command;


    // 3.执行命令
    [self.conmmand execute:@1];

    // 4.订阅RACCommand中的信号
    [command.executionSignals subscribeNext:^(id x) {

        [x subscribeNext:^(id x) {

            NSLog(@"%@",x);
        }];

    }];

    // RAC高级用法
    // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号
    [command.executionSignals.switchToLatest subscribeNext:^(id x) {

        NSLog(@"%@",x);
    }];

    // 5.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。
    [[command.executing skip:1] subscribeNext:^(id x) {

        if ([x boolValue] == YES) {
            // 正在执行
            NSLog(@"正在执行");

        }else{
            // 执行完成
            NSLog(@"执行完成");
        }

    }];
</racsubscriber></code></pre>

<ul>
<li><code>RACScheduler</code>:RAC中的队列，用GCD封装的。</li>
<li><code>RACUnit</code>:表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</li>
<li><code>RACEvent</code>: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</li>
</ul>
<h3 id="3-ReactiveCocoa开发中常见用法。"><a href="#3-ReactiveCocoa开发中常见用法。" class="headerlink" title="3.ReactiveCocoa开发中常见用法。"></a>3.ReactiveCocoa开发中常见用法。</h3><p>3.1 代替代理：</p>
<ul>
<li><code>rac_signalForSelector</code>：用于替代代理。</li>
</ul>
<p>3.2 代替KVO :</p>
<ul>
<li><code>rac_valuesAndChangesForKeyPath</code>：用于监听某个对象的属性改变。</li>
</ul>
<p>3.3 监听事件:</p>
<ul>
<li><code>rac_signalForControlEvents</code>：用于监听某个事件。</li>
</ul>
<p>3.4 代替通知:</p>
<ul>
<li><code>rac_addObserverForName</code>:用于监听某个通知。</li>
</ul>
<p>3.5 监听文本框文字改变:</p>
<ul>
<li><code>rac_textSignal</code>:只要文本框发出改变就会发出这个信号。</li>
</ul>
<p>3.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面</p>
<ul>
<li><code>rac_liftSelector:withSignalsFromArray:Signals</code>:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
<li>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</li>
</ul>
<p>3.7 代码演示</p>
<pre><code>
// 1.代替代理
    // 需求：自定义redView,监听红色view中按钮点击
    // 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情
    // rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。
    // 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。
    [[redV rac_signalForSelector:@selector(btnClick:)] subscribeNext:^(id x) {
        NSLog(@"点击红色按钮");
    }];

    // 2.KVO
    // 把监听redV的center属性改变转换成信号，只要值改变就会发送信号
    // observer:可以传入nil
    [[redV rac_valuesAndChangesForKeyPath:@"center" options:NSKeyValueObservingOptionNew observer:nil] subscribeNext:^(id x) {

        NSLog(@"%@",x);

    }];

    // 3.监听事件
    // 把按钮点击事件转换为信号，点击按钮，就会发送信号
    [[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {

        NSLog(@"按钮被点击了");
    }];

    // 4.代替通知
    // 把监听到的通知转换信号
    [[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) {
        NSLog(@"键盘弹出");
    }];

    // 5.监听文本框的文字改变
   [_textField.rac_textSignal subscribeNext:^(id x) {

       NSLog(@"文字改变了%@",x);
   }];

   // 6.处理多个请求，都返回结果的时候，统一做处理.
    RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {

        // 发送请求1
        [subscriber sendNext:@"发送请求1"];
        return nil;
    }];

    RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
        // 发送请求2
        [subscriber sendNext:@"发送请求2"];
        return nil;
    }];

    // 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。
    [self rac_liftSelector:@selector(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];


}
// 更新UI
- (void)updateUIWithR1:(id)data r2:(id)data1
{
    NSLog(@"更新UI%@  %@",data,data1);
}
</racsubscriber></racsubscriber></code></pre>


<h3 id="4-ReactiveCocoa常见宏。"><a href="#4-ReactiveCocoa常见宏。" class="headerlink" title="4.ReactiveCocoa常见宏。"></a>4.ReactiveCocoa常见宏。</h3><p>4.1 <code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code>:用于给某个对象的某个属性绑定。     </p>
<pre><code>// 只要文本框文字改变，就会修改label的文字
RAC(self.labelView,text) = _textField.rac_textSignal;    
</code></pre><p>4.2 <code>RACObserve(self, name)</code>:监听某个对象的某个属性,返回的是信号。</p>
<pre><code>[RACObserve(self.view, center) subscribeNext:^(id x) {

    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>4.3 <code>@weakify(Obj)和@strongify(Obj)</code>,一般两个都是配套使用,解决循环引用问题.<br>4.4 <code>RACTuplePack</code>：把数据包装成RACTuple（元组类）</p>
<pre><code>// 把参数中的数据包装成元组
RACTuple *tuple = RACTuplePack(@10,@20);
</code></pre><p>4.5 <code>RACTupleUnpack</code>：把RACTuple（元组类）解包成对应的数据。</p>
<pre><code> // 把参数中的数据包装成元组
RACTuple *tuple = RACTuplePack(@&quot;xmg&quot;,@20);

// 解包元组，会把元组的值，按顺序给参数里面的变量赋值
// name = @&quot;xmg&quot; age = @20
RACTupleUnpack(NSString *name,NSNumber *age) = tuple;
</code></pre><!-- more -->
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于RAC的一些资料]]></title>
      <url>http://yoursite.com/2016/04/23/%E5%85%B3%E4%BA%8ERAC%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/</url>
      <content type="html"><![CDATA[<p>看了这么多RAC资料，在这里我整理了一下，以备学习。</p>
<a id="more"></a>
<h5 id="何为函数式编程"><a href="#何为函数式编程" class="headerlink" title="何为函数式编程"></a>何为函数式编程</h5><ul>
<li><a href="http://valiantcat.com/2016/06/03/%E4%BB%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%88%B0%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" target="_blank" rel="external">从函数调用到函数式编程</a></li>
</ul>
<h5 id="RP入门"><a href="#RP入门" class="headerlink" title="RP入门"></a>RP入门</h5><ul>
<li><a href="https://github.com/benjycui/introrx-chinese-edition" target="_blank" rel="external">RP入门</a></li>
</ul>
<h5 id="RAC思想"><a href="#RAC思想" class="headerlink" title="RAC思想"></a>RAC思想</h5><ul>
<li><p><a href="http://www.jianshu.com/p/25922584bc43" target="_blank" rel="external">iOS Reactive Cocoa使用浅析</a></p>
</li>
<li><p><a href="http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/index.html" target="_blank" rel="external">ReactiveCocoa 讨论会</a></p>
</li>
</ul>
<h5 id="RAC基础篇"><a href="#RAC基础篇" class="headerlink" title="RAC基础篇"></a>RAC基础篇</h5><ul>
<li><p><a href="http://www.guiyongdong.com/2016/08/11/%E5%88%9D%E8%AF%86ReactiveCocoa/" target="_blank" rel="external">初识ReactiveCocoa</a></p>
</li>
<li><p><a href="http://www.guiyongdong.com/2016/08/12/%E6%B7%B1%E5%85%A5ReactiveCocoa/" target="_blank" rel="external">深入ReactiveCocoa</a></p>
</li>
</ul>
<h5 id="非常不错的RAC入门教程"><a href="#非常不错的RAC入门教程" class="headerlink" title="非常不错的RAC入门教程"></a>非常不错的RAC入门教程</h5><ul>
<li><p><a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1" target="_blank" rel="external">ReactiveCocoa入门教程——第一部分对应的中文版</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">Reactive Cocoa Tutorial [1] = 神奇的Macros</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_2_racstream/" target="_blank" rel="external">Reactive Cocoa Tutorial [2] = 百变RACStream</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/" target="_blank" rel="external">Reactive Cocoa Tutorial [3] = RACSignal的巧克力工厂</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/04/19/rac_4_filters/" target="_blank" rel="external">Reactive Cocoa Tutorial [4] = 只取所需的Filters</a></p>
</li>
<li><p><a href="http://leichunfeng.github.io/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan" target="_blank" rel="external">ReactiveCocoa v2.5 源码解析之架构总览</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/d262f2c55fbe" target="_blank" rel="external">RAC核心元素与信号流</a></p>
</li>
</ul>
<h5 id="来自美团的对冷热信号的分析"><a href="#来自美团的对冷热信号的分析" class="headerlink" title="来自美团的对冷热信号的分析"></a>来自美团的对冷热信号的分析</h5><ul>
<li><p><a href="http://tech.meituan.com/RACSignalSubscription.html" target="_blank" rel="external">RACSignal的Subscription深入分析 - 美团点评技术团队</a></p>
</li>
<li><p><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（一）</a></p>
</li>
<li><p><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-2.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号</a></p>
</li>
<li><p><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号</a></p>
</li>
<li><p><a href="http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html" target="_blank" rel="external">ReactiveCocoa中潜在的内存泄漏及解决方案</a></p>
</li>
<li><p><a href="http://tech.meituan.com/RACSignalSubscription.html" target="_blank" rel="external">RACSignal的Subscription深入分析</a></p>
</li>
</ul>
<h5 id="RAC源码解析"><a href="#RAC源码解析" class="headerlink" title="RAC源码解析"></a>RAC源码解析</h5><ul>
<li><p><a href="http://www.jianshu.com/p/d262f2c55fbe" target="_blank" rel="external">RAC核心元素与信号流</a></p>
</li>
<li><p><a href="http://ios.jobbole.com/85019/" target="_blank" rel="external">剖析@weakify 和 @strongify</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/baeebca1f6f4" target="_blank" rel="external">ReactiveCocoa源码阅读之前序</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/d5e4dc7e592e" target="_blank" rel="external">ReactiveCocoa源码阅读之RACSignal(一)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/bcdea71ba824" target="_blank" rel="external">ReactiveCocoa源码阅读之RACSignal(二)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/7c1ddba2b3a4" target="_blank" rel="external">ReactiveCocoa源码阅读之bind函数</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/f939bf6afc93" target="_blank" rel="external">ReactiveCocoa源码阅读之攻略flatten</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/f3b00e90035d" target="_blank" rel="external">ReactiveCocoa源码阅读之switchToLatest/combineLatestWith</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/a151e5cb0aae" target="_blank" rel="external">ReactiveCocoa源码阅读之RACScheduler</a></p>
</li>
</ul>
<h5 id="MVVM-With-ReactiveCocoa"><a href="#MVVM-With-ReactiveCocoa" class="headerlink" title="MVVM With ReactiveCocoa"></a>MVVM With ReactiveCocoa</h5><ul>
<li><p><a href="http://www.jianshu.com/p/b2fe0920e3aa" target="_blank" rel="external">MVVM与ReactiveCocoa的运用(Part1)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/b51344f4f3a3" target="_blank" rel="external">MVVM与ReactiveCocoa的运用(Part2)</a></p>
</li>
<li><p><a href="https://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 1/2</a></p>
</li>
<li><p><a href="https://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>
</li>
<li><p><a href="http://leichunfeng.github.io/blog/2016/02/27/mvvm-with-reactivecocoa" target="_blank" rel="external">MVVM With ReactiveCocoa</a></p>
</li>
</ul>
<h5 id="RAC其它"><a href="#RAC其它" class="headerlink" title="RAC其它"></a>RAC其它</h5><ul>
<li><p><a href="http://www.jianshu.com/p/fccba7be1ca1" target="_blank" rel="external">ReactiveCocoa 4 文档翻译目录</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/0ea216239efb" target="_blank" rel="external">ReactiveCocoa 4 图解之一——事件（Event）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/ba5247d713a9" target="_blank" rel="external">ReactiveCocoa 4 图解之二——监听器（Observer）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/7a4a1d005aee" target="_blank" rel="external">ReactiveCocoa 4 图解之三——存根（Disposable)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/f0c945e5b2fe" target="_blank" rel="external">ReactiveCocoa 4 图解之五——信号（Signal)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/617063a81136" target="_blank" rel="external">ReactiveCocoa 4 图解之六——信号发生器（SignalProducer）</a></p>
</li>
</ul>
<!-- more -->
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[聊一聊GCD的那些事]]></title>
      <url>http://yoursite.com/2016/04/15/%E8%81%8A%E4%B8%80%E8%81%8AGCD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。</p>
<a id="more"></a>
<p><strong>目录</strong></p>
<blockquote>
<ol>
<li>文字描述</li>
<li>Dispatch Queue</li>
<li>dispatch_sync&amp;dispatch_async</li>
<li>创建的线程任务有四种执行方式</li>
<li>Dispatch Group</li>
<li>Dispatch Block</li>
<li>dispatch_after</li>
<li>dispatch_apply</li>
<li>dispatch_once</li>
<li>dispatch_barrier_async</li>
<li>dispatch_set_target_queue</li>
<li>dispatch_semaphore_t(信号量)</li>
<li>GCD定时器</li>
</ol>
</blockquote>
<h3 id="1-文字描述"><a href="#1-文字描述" class="headerlink" title="1. 文字描述"></a>1. 文字描述</h3><blockquote>
<p>GCD英文全称：Grand Central Dispatch 翻译就是 宏大的中央调度，是苹果开发的一种支持并行操作的机制,基于C语言，提供了非常多强大的函数</p>
</blockquote>
<p>在了解GCD并使用之前，必须要掌握四个名词：<strong>串行</strong>，<strong>并发</strong>，<strong>同步</strong>，<strong>异步</strong></p>
<p><strong>串行(Serial)：</strong><br>一个任务执行完, 再执行下一个任务</p>
<p><strong>并发 (Concurrent)：</strong><br>多个任务同时执行(自动开启多个线程),只有在异步函数下才有效</p>
<p><strong>同步(Synchronous)：</strong><br>在当前线程中执行任务，不具备开启新线程的能力<br>提交的任务在执行完成后才会返回<br>同步函数: dispatch_sync()</p>
<p><strong>异步 (Asynchronous)：</strong><br>在新的线程中执行任务, 具备开启线程的能力<br>在新线程中执行任务，具备开启新线程的能力<br>提交的任务立刻返回，在后台队列中执行<br>异步函数: dispatch_async()</p>
<hr>
<h3 id="2-Dispatch-Queue"><a href="#2-Dispatch-Queue" class="headerlink" title="2.Dispatch Queue"></a>2.Dispatch Queue</h3><p>Dispatch Queue是执行处理的等待队列, 按照先进先出(FIFO, First-In-First-Out)的顺序进行任务处理.<br>开发者将需要执行的任务添加到合适的Dispatch Queue中即可，Dispatch Queue会根据任务添加的顺序先到先执行，其中有以下几种队列：</p>
<p>另外, 队列分两种, 一种是<strong>串行队列(Serial Dispatch Queue)</strong>, 一种是<strong>并行队列(Concurrent Dispatch Queue)</strong>.</p>
<table>
<thead>
<tr>
<th>Dispatch Queue的种类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Dispatch Queue</td>
<td style="text-align:center">等待现在执行中处理结束</td>
</tr>
<tr>
<td>Concurrent Dispatch Queue</td>
<td style="text-align:center">不等待现在执行中处理结束</td>
</tr>
</tbody>
</table>
<pre><code>
//创建一个串行队列
dispatch_queue_t serialQueue=dispatch_queue_create("com.serial.queue", DISPATCH_QUEUE_SERIAL);

//创建一个并发队列
dispatch_queue_t concurrentQueue=dispatch_queue_create("com.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);

//第一个参数为队列名，第二个参数为队列类型，当然，第二个参数人如果写NULL，创建出来的也是一个串行队列。然后我们在异步线程来执行这个队列：
</code></pre>

<p>另外系统为我们准备了两个队列</p>
<ul>
<li><p><strong>main dispatch queue</strong><br>功能跟主线程一样，通过dispatch_get_main_queue()来获取，提交到main queue的任务实际上都是在主线程执行的，所以这是一个串行队列<br><code>dispatch_queue_t queue = dispatch_get_main_queue();</code></p>
</li>
<li><p><strong>global dispatch queues</strong><br>系统给每个应用提供四个全局的并发队列，这四个队列分别有不同的优先级：高、默认、低以及后台，用户不能去创建全局队列，只能根据优先级去获取:</p>
<pre><code>dispatch_queue_t queue  = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</code></pre>    



</li>
</ul>
<hr>
<h3 id="3-dispatch-sync-amp-dispatch-async"><a href="#3-dispatch-sync-amp-dispatch-async" class="headerlink" title="3.dispatch_sync&amp;dispatch_async"></a>3.dispatch_sync&amp;dispatch_async</h3><p>执行队列中任务的两种方式，dispatch_sync是同步任务，dispatch_async是异步任务</p>
<p>1.<strong>用同步的方式执行任务(同步：synchronization)</strong>， 只能在当前线程中执行任务，不具备开启新线程的能力</p>
<pre><code>/*
 *  第一个参数：该任务所在的队列
 *  第二个参数：该任务要做的事情
 */
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code></pre>

<ul>
<li><p>假如我指定的队列A是串行队列，则该队列中只能有一个线程，也就是说我放在队列A中的任务，所以必须得一个一个的执行。不仅如此，在上面我们还手动选择了在队列A中用同步的方式执行任务，这也限制了，队列中的任务只能一个一个执行。</p>
</li>
<li><p>假如我指定的队列A是并行队列，则该队列中可以开辟多个线程去执行任务，虽然如此，但由于我们在上面手动选择了在队列A中用同步的方式执行线程，所以队列A中的任务也只能一个一个去执行，<strong>不能开辟多线程同时执行</strong>。</p>
</li>
</ul>
<p>2.用异步的方式执行任务(异步：asynchronous)，可以在新的线程中执行任务，具备开启新线程的能力。</p>
<pre><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code></pre>

<ul>
<li>假如此时我指定的队列B是并行队列，则表明该队列中可以存在多个线程，又因为我们采用的是异步的方式执行任务，所以在这个队列的任务可以实现同时运行。</li>
<li>假如此时我指定的队列B是串行队列，则表明该队列中，只能有一个线程，所以尽管我采用异步的方式执行任务，但该队列中的任务还是只能一个一个的运行。</li>
</ul>
<hr>
<h3 id="4-创建的线程任务有四种执行方式"><a href="#4-创建的线程任务有四种执行方式" class="headerlink" title="4.创建的线程任务有四种执行方式"></a>4.创建的线程任务有四种执行方式</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/GCD1.png?raw=true" alt=""></p>
<h5 id="1-串行队列同步执行任务"><a href="#1-串行队列同步执行任务" class="headerlink" title="1. 串行队列同步执行任务"></a>1. 串行队列同步执行任务</h5><ul>
<li>同步不具有开辟新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程中执行任务。</li>
<li>按照串行的方式去执行任务</li>
</ul>
<pre><code>-(void)syncSERIAL{
    NSLog(@"star");
    //不会开辟新的线程
    dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_1 ");
    });
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_2 ");
    });
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_3 ");
    });

    NSLog(@"end");

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:08:09.695 GCD_Demo[8196:1029563] star
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_1 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_2 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_3 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] end</code></pre>

<p><strong>由于是同步操作，不能开辟线程，所以都是在主线程并按照顺序执行</strong></p>
<h5 id="2-串行队列异步执行任务"><a href="#2-串行队列异步执行任务" class="headerlink" title="2. 串行队列异步执行任务"></a>2. 串行队列异步执行任务</h5><ul>
<li>异步具有创建新线程的能力，会开辟新的线程去执行任务</li>
<li>按照串行的方式去执行任务</li>
</ul>
<pre><code>-(void)asyncSERIAL{
    NSLog(@"star");

    //会开辟新的线程,但是是串行执行任务
    dispatch_queue_t queue=dispatch_queue_create("ki", DISPATCH_QUEUE_SERIAL);
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:3];
        NSLog(@"SERIAL_work_1 ");
    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"SERIAL_work_2 ");
    });
    dispatch_async(queue, ^{
        NSLog(@"SERIAL_work_3 ");
    });

    NSLog(@"end");

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:09:58.494 GCD_Demo[8213:1031268] star
2016-07-20 20:09:58.495 GCD_Demo[8213:1031268] end
2016-07-20 20:10:01.496 GCD_Demo[8213:1031315] SERIAL_work_1 
2016-07-20 20:10:03.502 GCD_Demo[8213:1031315] SERIAL_work_2 
2016-07-20 20:10:03.502 GCD_Demo[8213:1031315] SERIAL_work_3</code></pre>

<p><strong>因为是异步操作，所以有个编号为2的子线程被开辟，但有因为是串行队列，所以只开辟了一个线程。最终造就了三个任务顺序执行。</strong></p>
<h5 id="3-并行队列同步执行任务"><a href="#3-并行队列同步执行任务" class="headerlink" title="3. 并行队列同步执行任务"></a>3. 并行队列同步执行任务</h5><ul>
<li>同步不具有创建新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程去执行任务</li>
<li>按照同步的方式去执行任务</li>
</ul>
<pre><code>-(void)syncCONCURRENT{
  NSLog(@"star");
  //不会开辟新的线程
  //串行执行命令
  dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
  dispatch_sync(queue, ^{
      [NSThread sleepForTimeInterval:3];
      NSLog(@"CONCURRENT_work_1 ");
  });
  dispatch_sync(queue, ^{
      [NSThread sleepForTimeInterval:2];
      NSLog(@"CONCURRENT_work_2 ");
  });
  dispatch_sync(queue, ^{
      NSLog(@"CONCURRENT_work_3 ");
  });

  NSLog(@"end");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:13:03.753 GCD_Demo[8232:1033759] star
2016-07-20 20:13:06.755 GCD_Demo[8232:1033759] CONCURRENT_work_1 
2016-07-20 20:13:08.756 GCD_Demo[8232:1033759] CONCURRENT_work_2 
2016-07-20 20:13:08.756 GCD_Demo[8232:1033759] CONCURRENT_work_3 
2016-07-20 20:13:08.757 GCD_Demo[8232:1033759] end</code></pre>

<p><strong>虽然并行队列决定了该队列中可以有多个线程，但由于是同步操作，不能开辟线程，所以还都是在主线程中按顺序执行。</strong></p>
<h5 id="4-并发队列异步执行任务-常用"><a href="#4-并发队列异步执行任务-常用" class="headerlink" title="4. 并发队列异步执行任务(常用)"></a>4. 并发队列异步执行任务(常用)</h5><ul>
<li>异步具有创建新线程的能力，会开辟新的线程去执行任务，不会在当前程序的主线程去执行任务</li>
<li>按照并发的方式去执行任务</li>
</ul>
<pre><code>-(void)asyncCONCURRENT{
  NSLog(@"star");

  //一个队列 为 每个任务开辟一个线程
  dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:3];
      NSLog(@"CONCURRENT_work_1 ");
  });
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:2];
      NSLog(@"CONCURRENT_work_2 ");
  });
  dispatch_async(queue, ^{
      NSLog(@"CONCURRENT_work_3 ");
  });

  NSLog(@"end");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:18:26.768 GCD_Demo[8256:1038143] star
2016-07-20 20:18:26.768 GCD_Demo[8256:1038143] end
2016-07-20 20:18:26.769 GCD_Demo[8256:1038192] CONCURRENT_work_3 
2016-07-20 20:18:28.771 GCD_Demo[8256:1038179] CONCURRENT_work_2 
2016-07-20 20:18:29.773 GCD_Demo[8256:1038188] CONCURRENT_work_1</code></pre>

<p><strong>并行队列可以里可以有多个线程，同步执行的方式又可以开辟多个线程，所以这里实现了多个线程并行执行。</strong></p>
<hr>
<h3 id="5-Dispatch-Group"><a href="#5-Dispatch-Group" class="headerlink" title="5.Dispatch Group"></a>5.Dispatch Group</h3><p>当我们想在gcd queue中所有的任务执行完毕之后做些特定事情的时候，也就是队列的同步问题，如果队列是串行的话，那将该操作最后添加到队列中即可，但如果队列是并行队列的话，这时候就可以利用dispatch_group来实现了，dispatch_group能很方便的解决同步的问题。dispatch_group_create可以创建一个group对象，然后可以添加block到该组里面，下面看下它的一些用法：</p>
<ul>
<li><p>dispatch_group_notify<br>  是通过异步的方式通知，所以，不会阻塞线程</p>
<pre><code>-(void)asyncGroupNotify
{
NSLog(@"star");
dispatch_group_t group=dispatch_group_create();
dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:1];
    NSLog(@"group_work_1");
});
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:6];
    NSLog(@"group_work_2");
});
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:2];
    NSLog(@"group_work_3");
});

dispatch_group_notify(group, queue, ^{
    NSLog(@"dispatch_group_Notify 结束");
});
}</code></pre>

</li>
</ul>
<p>运行结果</p>
<pre><code>2016-07-21 13:51:40.600 GCD_Demo[9044:1162213] star
2016-07-21 13:51:41.605 GCD_Demo[9044:1162359] group_work_1
2016-07-21 13:51:42.608 GCD_Demo[9044:1162389] group_work_3
2016-07-21 13:51:46.603 GCD_Demo[9044:1162349] group_work_2
2016-07-21 13:51:46.605 GCD_Demo[9044:1162349] dispatch_group_Notify 结束</code></pre>

<ul>
<li>dispatch_group_wait<br>  会阻塞当前线程，知道任务都完成时才会继续执行下面的代码</li>
</ul>
<pre><code>-(void)asyncGroupWait
{
    NSLog(@"star");
    dispatch_group_t group=dispatch_group_create();
    dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"group_work_1");
    });
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:6];
        NSLog(@"group_work_2");
    });
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"group_work_3");
    });

    //在此设置了一个12秒的等待时间，如果group的执行结束没有到12秒那么就返回0
    //如果执行group的执行时间超过了12秒，那么返回非0 数值，
    //在使用dispatch_group_wait函数的时候，会阻塞当前线程，阻塞的时间 在wait函数时间值和当前group执行时间值取最小的。
    long kk=dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 12 * NSEC_PER_SEC));
    if(kk==0)
    {
         NSLog(@"dispatch_group_wait 结果1");
    }
    else
    {
         NSLog(@"dispatch_group_wait 结果2");
    }

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 13:56:47.471 GCD_Demo[9065:1165380] star
2016-07-21 13:56:48.472 GCD_Demo[9065:1165494] group_work_1
2016-07-21 13:56:49.476 GCD_Demo[9065:1165502] group_work_3
2016-07-21 13:56:53.475 GCD_Demo[9065:1165485] group_work_2
2016-07-21 13:56:53.475 GCD_Demo[9065:1165380] dispatch_group_wait 结果1</code></pre>

<ul>
<li>dispatch_group_enter&amp;dispatch_group_leave<br>  假如我们不想使用dispatch_group_async异步的将任务丢到group中去执行，这时候就需要用到dispatch_group_enter跟dispatch_group_leave方法，这两个方法要配对出现，以下这两种方法是等价的：</li>
</ul>
<pre><code>-(void)asyncGroupEnter
{
  // 群组－统一监控一组任务
  dispatch_group_t group = dispatch_group_create();

  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

  // 1> 入组 -> 之后的 block 会被 group 监听
  // dispatch_group_enter 一定和 dispatch_group_leave 要配对出现
  dispatch_group_enter(group);
  dispatch_async(queue, ^{
      NSLog(@"dispatch_async_work1");

      // block 的末尾，所有任务执行完毕后，添加一个出组
      dispatch_group_leave(group);
  });

  //  再次入组
  dispatch_group_enter(group);
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:6];

      NSLog(@"dispatch_async_work1");

      // block 的末尾，所有任务执行完毕后，添加一个出组
      dispatch_group_leave(group);
  });

  // 群组结束
  dispatch_group_notify(group, dispatch_get_main_queue(), ^{
      NSLog(@"OVER");
  });  
  NSLog(@"come here");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 15:21:40.707 GCD_Demo[9256:1205427] come here
2016-07-21 15:21:40.707 GCD_Demo[9256:1205465] dispatch_async_work1
2016-07-21 15:21:46.709 GCD_Demo[9256:1205460] dispatch_async_work1
2016-07-21 15:21:46.710 GCD_Demo[9256:1205427] OVER</code></pre>



<hr>
<h3 id="6-Dispatch-Block"><a href="#6-Dispatch-Block" class="headerlink" title="6. Dispatch Block"></a>6. Dispatch Block</h3><p>添加到gcd队列中执行的任务是以block的形式添加的，block封装了需要执行功能，block带来的开发效率提升就不说了，gcd跟block可以说是一对好基友，能够很好的配合使用。</p>
<pre><code>-(void)dispatchBlock
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block=dispatch_block_create(0, ^{
        NSLog(@"dispatchBlock_work");
    });

    dispatch_sync(queue, block);
}</code></pre>

<h5 id="1-dispatch-block-wait"><a href="#1-dispatch-block-wait" class="headerlink" title="1.dispatch_block_wait"></a>1.dispatch_block_wait</h5><p>当需要等待前面的任务执行完毕时，我们可以使用dispatch_block_wait这个接口，设置等待时间DISPATCH_TIME_FOREVER会一直等待直到前面的任务完成.用法跟dispatch_group_wait类似</p>
<pre><code>-(void)dispatchBlockWait
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block = dispatch_block_create(0, ^{
        NSLog(@"before sleep");
        [NSThread sleepForTimeInterval:6];
        NSLog(@"after sleep");
    });
    dispatch_async(queue, block);
    //等待前面的任务执行完毕
    long kk=dispatch_block_wait(block, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));
    if(kk==0)
    {
        NSLog(@"coutinue");
    }
    else
    {
        NSLog(@"timeOut！！！");
    }
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:28:38.313 GCD_Demo[9533:1251011] before sleep
2016-07-21 16:28:41.314 GCD_Demo[9533:1250971] timeOut！！！
2016-07-21 16:28:44.318 GCD_Demo[9533:1251011] after sleep</code></pre>

<h5 id="2-dispatch-block-notify"><a href="#2-dispatch-block-notify" class="headerlink" title="2.dispatch_block_notify"></a>2.dispatch_block_notify</h5><p>dispatch_block_notify当观察的某个block执行结束之后立刻通知提交另一特定的block到指定的queue中执行，该函数有三个参数，第一参数是需要观察的block，第二个参数是被通知block提交执行的queue，第三参数是当需要被通知执行的block</p>
<pre><code>-(void)dispatchBlockNotify
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t previousBlock = dispatch_block_create(0, ^{
        NSLog(@"previousBlock begin");
        [NSThread sleepForTimeInterval:2];
        NSLog(@"previousBlock done");
    });
    dispatch_async(queue, previousBlock);
    dispatch_block_t notifyBlock = dispatch_block_create(0, ^{
        NSLog(@"notifyBlock");
    });
    //当previousBlock执行完毕后，提交notifyBlock到global queue中执行
    dispatch_block_notify(previousBlock, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), notifyBlock);
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:38:19.756 GCD_Demo[9664:1261328] previousBlock begin
2016-07-21 16:38:21.762 GCD_Demo[9664:1261328] previousBlock done
2016-07-21 16:38:21.762 GCD_Demo[9664:1261329] notifyBlock</code></pre>

<h5 id="3-dispatch-block-cancel"><a href="#3-dispatch-block-cancel" class="headerlink" title="3. dispatch_block_cancel"></a>3. dispatch_block_cancel</h5><p>可以取消提交到队列的block</p>
<pre><code>-(void)dispatchBlockCancel
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
    dispatch_block_t block1 = dispatch_block_create(0, ^{
        NSLog(@"block1 begin");
        [NSThread sleepForTimeInterval:1];
        NSLog(@"block1 done");
    });
    dispatch_block_t block2 = dispatch_block_create(0, ^{
        NSLog(@"block2 ");
    });
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_block_cancel(block2);
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:50:28.140 GCD_Demo[9723:1272259] block1 begin
2016-07-21 16:50:29.144 GCD_Demo[9723:1272259] block1 done</code></pre>


<hr>
<h3 id="7-dispatch-after"><a href="#7-dispatch-after" class="headerlink" title="7.dispatch_after"></a>7.dispatch_after</h3><p>来延迟执行的GCD方法，因为在主线程中我们不能用sleep来延迟方法的调用，所以用它是最合适的，我们做一个简单的例子：</p>
<pre><code>-(void)dispatchAfter
{
    NSLog(@"dispatchAfter_star");
    int64_t time=2*NSEC_PER_SEC;

    dispatch_queue_t mainQueue=dispatch_get_main_queue();

        for (int i=0; i<5; i++)="" {="" dispatch_time_t="" distime="dispatch_time(DISPATCH_TIME_NOW," time*i);="" dispatch_after(distime,="" mainqueue,="" ^{="" nslog(@"dispatchafter_work");="" });="" }="" }<="" code=""></5;></code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:12:07.204 GCD_Demo[9439:1237251] dispatchAfter_star
2016-07-21 16:12:07.211 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:09.398 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:11.205 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:13.205 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:15.205 GCD_Demo[9439:1237251] dispatchAfter_work</code></pre>


<hr>
<h3 id="8-dispatch-apply"><a href="#8-dispatch-apply" class="headerlink" title="8.dispatch_apply"></a>8.dispatch_apply</h3><p>dispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次，如果队列是并发队列，则会并发执行block任务，dispatch_apply是一个同步调用，block任务执行n次后才返回。</p>
<pre><code>-(void)dispatchApply
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);


    dispatch_apply(6, queue, ^(size_t i) {
        NSLog(@"do a job %zu times",i);

    });
    NSLog(@"go on");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:04:54.558 GCD_Demo[9831:1284549] do a job 0 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284583] do a job 1 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284589] do a job 2 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284593] do a job 3 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284549] do a job 4 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284583] do a job 5 times
2016-07-21 17:04:54.566 GCD_Demo[9831:1284549] go on</code></pre>


<hr>
<h3 id="9-dispatch-once"><a href="#9-dispatch-once" class="headerlink" title="9.dispatch_once"></a>9.dispatch_once</h3><p>整个程序运行中只会执行一次，使用dispatch_once可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或者同步。所有问题都由GCD在底层处理。由于每次调用时都必须使用完全相同的标记，所以标记要声明成static。所以用在单例模式上是最好的</p>
<pre><code>static SingletonTimer * instance;
static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    instance = [[SingletonTimer alloc] init];
});

return instance;</code></pre>


<hr>
<h3 id="10-dispatch-barrier-async"><a href="#10-dispatch-barrier-async" class="headerlink" title="10. dispatch_barrier_async"></a>10. dispatch_barrier_async</h3><p>dispatch_barrier_async用于等待前面的任务执行完毕后自己才执行，而它后面的任务需等待它完成之后才执行。一个典型的例子就是数据的读写，通常为了防止文件读写导致冲突，我们会创建一个串行的队列，所有的文件操作都是通过这个队列来执行，比如FMDB，这样就可以避免读写冲突。不过其实这样效率是有提升的空间的，当没有更新数据时，读操作其实是可以并行进行的，而写操作需要串行的执行</p>
<pre><code>-(void)diapatchBarrier
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);

    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:6];
        NSLog(@"dispatch_async_work1");
    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"dispatch_async_work2");
    });
    dispatch_barrier_async(queue, ^{
        NSLog(@"dispatch_async_work3");
        [NSThread sleepForTimeInterval:1];

    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"dispatch_async_work4");
    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 15:54:24.402 GCD_Demo[9354:1225160] dispatch_async_work2
2016-07-21 15:54:28.403 GCD_Demo[9354:1225152] dispatch_async_work1
2016-07-21 15:54:28.403 GCD_Demo[9354:1225152] dispatch_async_work3
2016-07-21 15:54:30.412 GCD_Demo[9354:1225152] dispatch_async_work4</code></pre>


<hr>
<h3 id="11-dispatch-set-target-queue"><a href="#11-dispatch-set-target-queue" class="headerlink" title="11.dispatch_set_target_queue"></a>11.dispatch_set_target_queue</h3><p>1.系统的Global Queue是可以指定优先级的，那我们可以用到dispatch_set_target_queue这个方法来指定自己创建队列的优先级</p>
<pre><code>-(void)DispatchSet
{
    dispatch_queue_t serialDiapatchQueue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t dispatchgetglobalqueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
    dispatch_set_target_queue(serialDiapatchQueue, dispatchgetglobalqueue);
    dispatch_async(serialDiapatchQueue, ^{
        NSLog(@"我优先级低，先让让");
    });
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"我优先级高,我先block");
    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:22:02.512 GCD_Demo[9902:1297023] 我优先级高,我先block
2016-07-21 17:22:02.512 GCD_Demo[9902:1297035] 我优先级低，先让让</code></pre>

<p>2.dispatch_set_target_queue除了能用来设置队列的优先级之外，还能够创建队列的层次体系，当我们想让不同队列中的任务同步的执行时，我们可以创建一个串行队列，然后将这些队列的target指向新创建的队列即可</p>
<pre><code>-(void)dispatchSet2
{
    dispatch_queue_t targetQueue = dispatch_queue_create("target_queue", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue1 = dispatch_queue_create("queue1", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue2 = dispatch_queue_create("queue2", DISPATCH_QUEUE_CONCURRENT);


    dispatch_set_target_queue(queue1, targetQueue);
    dispatch_set_target_queue(queue2, targetQueue);

    dispatch_async(queue1, ^{
        [NSThread sleepForTimeInterval:3.f];
        NSLog(@"do job1");

    });
    dispatch_async(queue2, ^{
        [NSThread sleepForTimeInterval:2.f];
        NSLog(@"do job2");

    });
    dispatch_async(queue2, ^{
        [NSThread sleepForTimeInterval:1.f];
        NSLog(@"do job3");

    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:28:54.327 GCD_Demo[10043:1303853] do job1
2016-07-21 17:28:56.331 GCD_Demo[10043:1303853] do job2
2016-07-21 17:28:57.335 GCD_Demo[10043:1303853] do job3</code></pre>


<hr>
<h3 id="12-dispatch-semaphore-t"><a href="#12-dispatch-semaphore-t" class="headerlink" title="12.dispatch_semaphore_t"></a>12.dispatch_semaphore_t</h3><p>信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p>
<pre><code>- (void)downloadImageURLWithString:(NSString *)URLString
{
    // 1
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    NSURL *url = [NSURL URLWithString:URLString];
    __unused Photo *photo = [[Photo alloc]
                             initwithURL:url
                             withCompletionBlock:^(UIImage *image, NSError *error) {
                                 if (error) {
                                     XCTFail(@"%@ failed. %@", URLString, error);
                                 }

                                 // 2
                                 dispatch_semaphore_signal(semaphore);
                             }];

    // 3
    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);
    if (dispatch_semaphore_wait(semaphore, timeoutTime)) {
        XCTFail(@"%@ timed out", URLString);
    }
}</code></pre>

<p>下面来说明你代码中的信号量是如何工作的：</p>
<ol>
<li>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。</li>
<li>在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。</li>
<li>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！</li>
</ol>
<hr>
<h3 id="13-GCD定时器"><a href="#13-GCD定时器" class="headerlink" title="13.GCD定时器"></a>13.GCD定时器</h3><p>基于以前讲的runloop中的CFRunLoopTimerRef :</p>
<ul>
<li>CFRunLoopTimerRef是基于时间的触发器</li>
<li>CFRunLoopTimerRef基本上说的就是NSTimer,它受RunLoop的Mode的影响(Tracking,Defalult)</li>
<li>GCD的定时器不受RunLoop中Mode的影响(RunLoop内部也是基于GCD实现的,可以根据源码看到), 比如滚动TableView的时候,GCD的定时器不受影响</li>
<li>一般NSTimer不是特别准, NSTimer是在RunLoop中, RunLoop要处理各种东西(source,timer,observe),有时导致NSTimer不是特别准</li>
</ul>
<p>GCD定时器算是一个源(source),类型是Timer</p>
<pre><code>-(void)startTime{
    __block int timeout=30; //倒计时时间
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);

    dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行
    dispatch_source_set_event_handler(_timer, ^{
        if(timeout=0){ //倒计时结束，关闭
            dispatch_source_cancel(_timer);
            dispatch_async(dispatch_get_main_queue(), ^{
                //倒计时时间结束，回到主线程 根据自己需求设置

            });
        }else{
            //            int minutes = timeout / 60;
            int seconds = timeout % 60;
            NSString *strTime = [NSString stringWithFormat:@"%.2d", seconds];
            dispatch_async(dispatch_get_main_queue(), ^{
                //设置界面的按钮显示 根据自己需求设置
                NSLog(@"____%@",strTime);
                [l_timeButton setTitle:[NSString stringWithFormat:@"%@秒后重新发送",strTime] forState:UIControlStateNormal];
                l_timeButton.userInteractionEnabled = NO;

            });
            timeout--;

        }
    });
    dispatch_resume(_timer);

}</code></pre>






<!-- more -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[聊一聊NSOperation的那些事]]></title>
      <url>http://yoursite.com/2016/04/11/%E8%81%8A%E4%B8%80%E8%81%8ANSOperation%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>在iOS开发中，多线程技术用到最多的就是GCD和NSOperation，上一篇文章已经对GCD有了全面的了解，这篇文章简单的聊一聊NSOperation。<br><a id="more"></a></p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><ul>
<li>除了，NSThread和GCD实现多线程，配合使用NSOperation和NSOperationQueue也能实现多线程编程</li>
</ul>
<blockquote>
<p>NSOperation和NSOperationQueue<code>实现多线程的具体步骤</code></p>
</blockquote>
<ul>
<li>1、先将需要执行的操作封装到一个NSOperation的子类对象中<ul>
<li>实际上，NSOperation是个抽象类,并不具备封装操作的能力，必须使用它的子类</li>
</ul>
</li>
<li>2、然后将NSOperation对象添加到NSOperationQueue中</li>
<li>3、系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>4、将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
<h3 id="二、NSOperation"><a href="#二、NSOperation" class="headerlink" title="二、NSOperation"></a>二、NSOperation</h3><ul>
<li>如上所示：要实现多线程，必须要将执行的操作封装到NSOperation的子类对象中，那么NSOperation的子类有哪些？</li>
</ul>
<p><strong>1、使用NSOperation子类的方式有3种</strong></p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义子类继承NSOperation，实现内部相应main的方法封装操作</li>
</ul>
<blockquote>
<p>1.1 NSInvocationOperation</p>
</blockquote>
<ul>
<li><p>创建NSInvocationOperation对象<br><code>-(id)initWithTarget:(id)target selector:(SEL)selector object:(id)arg;</code></p>
</li>
<li><p>调用start方法开始执行操作</p>
<ul>
<li>默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作<pre><code>// 一旦执行操作，就会调用target的selector方法
-(void)start;
</code></pre></li>
<li>只有将NSOperation操作任务放到一个NSOperationQueue中，才会异步执行操作</li>
</ul>
</li>
<li><p>使用</p>
<pre><code>- (void)invocation
{    
  // 1.将操作封装到Operation中
  NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil];
  // 2.执行封装的操作
  // 如果直接执行NSInvocationOperation中的操作, 那么默认会在主线程中执行
  [op1 start];

  NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];
  [op2 start];
}
</code></pre>

</li>
</ul>
<blockquote>
<p>1.2 NSBlockOperation</p>
</blockquote>
<ul>
<li>注意点：<code>只要NSBlockOperation封装的操作数 &gt;1，就会异步执行操作</code></li>
<li>创建NSBlockOperation对象<pre><code>+(id)blockOperationWithBlock:(void(^)(void))block;</code></pre></li>
<li>通过addExecutionBlock:方法添加更多的操作<pre><code>-(void)addExecutionBlock:(void(^)(void))block;</code></pre></li>
<li><p>使用</p>
<pre><code>- (void)blockOperation
{
  // 1.封装操作
  NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
      NSLog(@"1- %@", [NSThread currentThread]);
  }];

  // 2.添加操作
  [op1 addExecutionBlock:^{
      NSLog(@"2- %@", [NSThread currentThread]);
  }];
  [op1 addExecutionBlock:^{
      NSLog(@"3- %@", [NSThread currentThread]);
  }];

  // 2.执行操作
  // 如果只封装了一个操作, 那么默认会在主线程中执行
  // 如果封装了多个操作, 那么除了第一个操作以外, 其它的操作会在子线程中执行
  [op1 start];
}</code></pre>

</li>
</ul>
<blockquote>
<p>1.3 自定义 NSOperation，继承NSOperation</p>
</blockquote>
<ul>
<li>如果是自定义类继承于NSOperation, 那么需要将操作写到自定义类的main方法中，重写main方法<ul>
<li>重写-(void)main方法的注意点<ul>
<li>自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）</li>
<li>经常通过-(BOOL)isCancelled方法检测操作是否被取消，对取消做出响应</li>
</ul>
</li>
</ul>
</li>
<li>这种实现方式封装操作, 可以提高代码的复用性</li>
<li>1.创建类JPOperation，继承NSOperation</li>
</ul>
<pre><code>#import <foundation foundation.h="">
@interface JPOperation : NSOperation

@end

#import "JPOperation.h"

@implementation JPOperation

// 我们要重写main方法，封装操作
- (void)main
{
    NSLog(@"%s, %@", __func__,[NSThread currentThread]);
}
@end
</foundation></code></pre>

<ul>
<li>2.使用自定义的NSOperation</li>
</ul>
<pre><code>// 1.封装操作
JPOperation *op1 = [[JPOperation alloc] init];
// 2.执行操作
[op1 start];

JPOperation *op2 = [[JPOperation alloc] init];
[op2 start];
</code></pre>


<h3 id="三、NSOperationQueue"><a href="#三、NSOperationQueue" class="headerlink" title="三、NSOperationQueue"></a>三、NSOperationQueue</h3><ul>
<li><code>NSOperationQueue的作用:</code><ul>
<li>如上所述：NSOperation可以调用start方法来执行任务，但默认是同步执行的</li>
<li>如果将NSOperation<code>添加到NSOperationQueue</code>（操作队列）中，<code>系统会自动异步执行NSOperation中的操作</code></li>
</ul>
</li>
<li>添加操作到NSOperationQueue：两个方法<ul>
<li>只要将一个任务添加到alloc/init的队列(默认并发，可以设置其为串行)中, 那么队列内部会自动调用start</li>
<li>如果想实现串行, 那么就设置队列的maxConcurrentOperationCount = 1</li>
</ul>
</li>
</ul>
<pre><code>-(void)addOperation:(NSOperation*)op;
-(void)addOperationWithBlock:(void(^)(void))block;
</code></pre>

<blockquote>
<p>基本使用</p>
</blockquote>
<ul>
<li>GCD队列:<ul>
<li>串行: 自己创建, 主队列</li>
<li>并发: 自己创建, 全局</li>
</ul>
</li>
<li>NSOperationQueue:<ul>
<li>自己创建: alloc/init –&gt; 默认是并发 –&gt; 也可以让它串行</li>
<li>主队列 : mainQueue</li>
</ul>
</li>
</ul>
<pre><code>#import "ViewController.h"
#import "JPOperation.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    // 2.封装任务
    JPOperation *op1 = [[JPOperation alloc] init];
    JPOperation *op2 = [[JPOperation alloc] init];

    // 3.将任务添加到队列中
    [queue addOperation:op1];
    [queue addOperation:op2];
}

- (void)block
{
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.将任务添加到队列中
    // addOperationWithBlock方法会做两件事情
    // 1.根据传入的block, 创建一个NSBlockOperation对象
    // 2.将内部创建好的NSBlockOperation对象, 添加到队列中
    [queue addOperationWithBlock:^{
        NSLog(@"1 = %@", [NSThread currentThread]);
    }];
    [queue addOperationWithBlock:^{
        NSLog(@"2 = %@", [NSThread currentThread]);
    }];
}

- (void)invation
{
    /*
     GCD队列:
     串行: 自己创建, 主队列
     并发: 自己创建, 全局

     NSOperationQueue:
     自己创建: alloc/init --> 默认是并发 --> 也可以让它串行
     主队列  : mainQueue
     */
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    //    NSOperationQueue *queue = [NSOperationQueue mainQueue];

    // 2.封装任务
    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil];
    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];

    // 3.将任务添加到队列中
    // 只要将一个任务添加到alloc/init的队列中, 那么队列内部会自动调用start
    // 只要将一个任务添加到alloc/init的队列中, 就会开启一个新的线程执行队列
    [queue addOperation:op1];
    [queue addOperation:op2];
}

- (void)demo
{
    NSLog(@"demo = %@", [NSThread currentThread]);
}
- (void)test
{
    NSLog(@"test = %@", [NSThread currentThread]);
}
@end
</code></pre>


<h3 id="四、NSOperatinoQueue的串行和并发-：-最大并发数"><a href="#四、NSOperatinoQueue的串行和并发-：-最大并发数" class="headerlink" title="四、NSOperatinoQueue的串行和并发 ： 最大并发数"></a>四、NSOperatinoQueue的串行和并发 ： 最大并发数</h3><ul>
<li>队列的maxConcurrentOperationCount最大并发数</li>
<li>maxConcurrentOperationCount 默认等于 -1, 代表不限制, 可以创建N多线程</li>
<li>alloc/init的NSOperatinoQueue队列默认就是并发， 如果想实现串行, 那么就设置maxConcurrentOperationCount = 1</li>
<li>注意: 最大并发数, 不能设置为0, 否则任务不会被执行 </li>
</ul>
<pre><code>#import "ViewController.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init
                               ];
    // maxConcurrentOperationCount 默认等于 -1, 代表不限制, 可以创建N多线程
    // 默认就是并发
    // 如果想实现串行, 那么就设置maxConcurrentOperationCount = 1
    // 注意: 最大并发数, 不能设置为0, 否则任务不会被执行 \
    如果想再主线程中执行任务, 那么直接创建mainQueu即可
//    queue.maxConcurrentOperationCount = 1;

    // 2.创建任务
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"1 = %@", [NSThread currentThread]);
    }];
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"2 = %@", [NSThread currentThread]);
    }];
    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"3 = %@", [NSThread currentThread]);
    }];

    // 3.将任务添加到队列中
    [queue addOperation:op1];
    [queue addOperation:op2];
    [queue addOperation:op3];   
}
@end
</code></pre>

<h3 id="五、NSOperationQueue的暂停-恢复-取消"><a href="#五、NSOperationQueue的暂停-恢复-取消" class="headerlink" title="五、NSOperationQueue的暂停-恢复-取消"></a>五、NSOperationQueue的暂停-恢复-取消</h3><blockquote>
<p>1、取消队列的所有操作</p>
</blockquote>
<ul>
<li>也可以调用NSOperation的-(void)cancel方法取消单个操作</li>
<li>注意点：<ul>
<li>任务只要被取消, 就不会再恢复了</li>
<li>取消任务和暂停任务一样, 不会取消当前正在执行的任务, 只能取消还未执行的任务<pre><code>-(void)cancelAllOperations;
</code></pre>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>2、暂停和恢复队列</p>
</blockquote>
<ul>
<li>注意:<ul>
<li>1.如果在任务执行的过程中暂停队列中的任务, 那么当前正在执行的任务并不会被暂停, 而是会暂停队列中的下一个任务</li>
<li>2.恢复任务, 是从队列第一个没有被执行过的任务开始恢复<pre><code>-(void)setSuspended:(BOOL)b;//如果是YES, 代表需要暂停，NO代表代表不需要暂停 ==  恢复执行
-(BOOL)isSuspended;
</code></pre>

</li>
</ul>
</li>
</ul>
<h3 id="六、NSOperationQueue线程间通信"><a href="#六、NSOperationQueue线程间通信" class="headerlink" title="六、NSOperationQueue线程间通信"></a>六、NSOperationQueue线程间通信</h3><blockquote>
<p>实例程序：开启子线程下载图片，下载好图片后，回到主线程进行更新UI</p>
</blockquote>
<pre><code>#import "ViewController.h"

@interface ViewController ()
@property (weak, nonatomic) IBOutlet UIImageView *imageView;

@end

@implementation ViewController

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    // 1.开启子线程下载图片
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperationWithBlock:^{
     // 子线程
        NSString *urlStr = @"https://www.baidu.com/img/bd_logo1.png";
    // url中文编码，防止乱码
    // urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        NSURL *url = [NSURL URLWithString:urlStr];
        NSData *data = [NSData dataWithContentsOfURL:url];
        // 2.生成下载好的图片
        UIImage *image = [UIImage imageWithData:data];

        // 3.回到主线程更新UI
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            NSLog(@"更新UI");
           // 主线程
            self.imageView.image = image;
        }];
    }];
}
@end
</code></pre>

<h3 id="七、操作依赖"><a href="#七、操作依赖" class="headerlink" title="七、操作依赖"></a>七、操作依赖</h3><ul>
<li>1、目的 -&gt; NSOperation之间可以设置依赖来保证执行顺序<ul>
<li>例如：一定要让操作A执行完后，才能执行操作B，可以这么写</li>
</ul>
</li>
<li>只要添加了依赖, 那么就会等依赖的任务执行完毕, 才会执行当前任务  <pre><code>[operationB addDependency:operationA];// 操作B依赖于操作A , A操作执行完才会执行操作B</code></pre></li>
<li>2、除了同一quere操作间建立依赖关系，当然也可以在不同queue的NSOperation之间创建依赖关系</li>
<li>注意点：<ul>
<li>不能相互依赖 -&gt; 比如A依赖B，B依赖A</li>
</ul>
</li>
</ul>
<blockquote>
<p>经典实例：合成图片</p>
</blockquote>
<pre><code>#import "ViewController.h"

@interface ViewController ()
@property (weak, nonatomic) IBOutlet UIImageView *imageView;

@end

@implementation ViewController
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];

    __block UIImage *image1 = nil;
    __block UIImage *image2 = nil;
    // 1.开启一个线程下载第一张图片
    NSOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        NSURL *url = [NSURL URLWithString:@"http://cdn.cocimg.com/assets/images/logo.png?v=201510272"];
        NSData *data = [NSData dataWithContentsOfURL:url];
        // 2.生成下载好的图片
        UIImage *image = [UIImage imageWithData:data];
        image1 = image;
    }];

    // 2.开启一个线程下载第二长图片
    NSOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        NSURL *url = [NSURL URLWithString:@"https://www.baidu.com/img/bd_logo1.png"];
        NSData *data = [NSData dataWithContentsOfURL:url];
        // 2.生成下载好的图片
        UIImage *image = [UIImage imageWithData:data];
        image2 = image;

    }];
    // 3.开启一个线程合成图片
    NSOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        UIGraphicsBeginImageContext(CGSizeMake(200, 200));
        [image1 drawInRect:CGRectMake(0, 0, 100, 200)];
        [image2 drawInRect:CGRectMake(100, 0, 100, 200)];
        UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();

        // 4.回到主线程更新UI
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            NSLog(@"回到主线程更新UI");
            self.imageView.image = newImage;
        }];
    }];


    // 监听任务是否执行完毕
    op1.completionBlock = ^{
        NSLog(@"第一张图片下载完毕");
    };
    op2.completionBlock = ^{
        NSLog(@"第二张图片下载完毕");
    };

    // 添加依赖
    // 只要添加了依赖, 那么就会等依赖的任务执行完毕, 才会执行当前任务
    // 注意:
    // 1.添加依赖, 不能添加循环依赖
    // 2.NSOperation可以跨队列添加依赖
    [op3 addDependency:op1];
    [op3 addDependency:op2];

    // 将任务添加到队列中
    [queue addOperation:op1];
    [queue addOperation:op2];
    [queue2 addOperation:op3];
}
@end</code></pre>

]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入ReactiveCocoa]]></title>
      <url>http://yoursite.com/2016/03/12/%E6%B7%B1%E5%85%A5ReactiveCocoa/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>(简称为RAC),上一篇文章，我们简单的对RAC有个初步的了解，在开发中，我们实际用到的基本都是上一篇所介绍的知识，这篇文章我们对RAC有个深入的了解。</p>
<a id="more"></a>
<h3 id="1-ReactiveCocoa常见操作方法介绍"><a href="#1-ReactiveCocoa常见操作方法介绍" class="headerlink" title="1.ReactiveCocoa常见操作方法介绍"></a>1.ReactiveCocoa常见操作方法介绍</h3><ul>
<li>1.1 ReactiveCocoa操作须知<ul>
<li>所有的信号（RACSignal）都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，而RACSignal继承RACStream。</li>
</ul>
</li>
<li>1.2  ReactiveCocoa操作思想<ul>
<li>运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.</li>
<li>Hook用处：截获API调用的技术。</li>
<li>Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。</li>
<li>RAC开发方式：RAC中核心开发方式，也是绑定，之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。</li>
<li>列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。</li>
</ul>
</li>
<li>1.3  ReactiveCocoa核心方法bind<ul>
<li>eactiveCocoa操作的核心方法是bind（绑定）,给RAC中的信号进行绑定，只要信号一发送数据，就能监听到，从而把发送数据改成自己想要的数据。</li>
<li>在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单.</li>
<li><code>bind</code>方法简单介绍和使用。</li>
</ul>
</li>
</ul>
<pre><code>
    // 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”            
    // 方式一:在返回结果后，拼接。
        [_textField.rac_textSignal subscribeNext:^(id x) {
            NSLog(@"输出:%@",x);
        }];

    // 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。
    // bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数
    // RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block。

    // RACStreamBindBlock:
    // 参数一(value):表示接收到信号的原始值，还没做处理
    // 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。
    // 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h。

    // bind方法使用步骤:
    // 1.传入一个返回值RACStreamBindBlock的block。
    // 2.描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。
    // 3.描述一个返回结果的信号，作为bindBlock的返回值。
    // 注意：在bindBlock中做信号结果的处理。

    // 底层实现:
    // 1.源信号调用bind,会重新创建一个绑定信号。
    // 2.当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。
    // 3.当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop)
    // 4.调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。
    // 5.订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。

    // 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。
    // 这里需要手动导入#import <reactivecocoa racreturnsignal.h="">，才能使用RACReturnSignal。

    [[_textField.rac_textSignal bind:^RACStreamBindBlock{

        // 什么时候调用:
        // block作用:表示绑定了一个信号.

        return ^RACStream *(id value, BOOL *stop){

            // 什么时候调用block:当信号有新的值发出，就会来到这个block。

            // block作用:做返回值的处理

            // 做好处理，通过信号返回出去.
            return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]];
        };

    }] subscribeNext:^(id x) {

        NSLog(@"%@",x);

    }];
</reactivecocoa></code></pre>

<ul>
<li>1.4 ReactiveCocoa操作方法之映射(flattenMap,Map)<ul>
<li><code>flattenMap</code>，<code>Map</code> 用于把源信号内容映射成新的内容。</li>
</ul>
</li>
</ul>
<p><code>flattenMap</code> 简单使用</p>
<pre><code>
    // 监听文本框的内容改变，把结构重新映射成一个新值.

    // flattenMap作用:把源信号的内容映射成一个新的信号，信号可以是任意类型。

    // flattenMap使用步骤:
    // 1.传入一个block，block类型是返回值RACStream，参数value
    // 2.参数value就是源信号的内容，拿到源信号的内容做处理
    // 3.包装成RACReturnSignal信号，返回出去。

    // flattenMap底层实现:
    // 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。
    // 1.当订阅绑定信号，就会生成bindBlock。
    // 2.当源信号发送内容，就会调用bindBlock(value, *stop)
    // 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号。
    // 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。
    // 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。



    [[_textField.rac_textSignal flattenMap:^RACStream *(id value) {

    // block什么时候 : 源信号发出的时候，就会调用这个block。

    // block作用 : 改变源信号的内容。

    // 返回值：绑定信号的内容.
    return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]];

    }] subscribeNext:^(id x) {

    // 订阅绑定信号，每当源信号发送内容，做完处理，就会调用这个block。

    NSLog(@"%@",x);

    }];
</code></pre>

<p><code>Map</code> 简单使用:</p>
<pre><code>
    // 监听文本框的内容改变，把结构重新映射成一个新值.

    // Map作用:把源信号的值映射成一个新的值

    // Map使用步骤:
    // 1.传入一个block,类型是返回对象，参数是value
    // 2.value就是源信号的内容，直接拿到源信号的内容做处理
    // 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。

    // Map底层实现:
    // 0.Map底层其实是调用flatternMap,Map中block中的返回的值会作为flatternMap中block中的值。
    // 1.当订阅绑定信号，就会生成bindBlock。
    // 3.当源信号发送内容，就会调用bindBlock(value, *stop)
    // 4.调用bindBlock，内部就会调用flattenMap的block
    // 5.flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。
    // 5.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。
    // 6.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。

    [[_textField.rac_textSignal map:^id(id value) {
        // 当源信号发出，就会调用这个block，修改源信号的内容
        // 返回值：就是处理完源信号的内容。
        return [NSString stringWithFormat:@"输出:%@",value];
    }] subscribeNext:^(id x) {

        NSLog(@"%@",x);
    }];
</code></pre>


<ul>
<li><p><code>FlatternMap</code>和<code>Map</code>的区别</p>
<ul>
<li>1.FlatternMap中的Block返回信号。</li>
<li>2.Map中的Block返回对象。</li>
<li>3.开发中，如果信号发出的值不是信号，映射一般使用Map</li>
<li>4.开发中，如果信号发出的值是信号，映射一般使用FlatternMap。</li>
</ul>
</li>
<li><p><code>总结</code>：signalOfsignals用FlatternMap。</p>
</li>
</ul>
<pre><code>
    // 创建信号中的信号
    RACSubject *signalOfsignals = [RACSubject subject];
    RACSubject *signal = [RACSubject subject];

    [[signalOfsignals flattenMap:^RACStream *(id value) {

     // 当signalOfsignals的signals发出信号才会调用

        return value;

    }] subscribeNext:^(id x) {

        // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。
        // 也就是flattenMap返回的信号发出内容，才会调用。

        NSLog(@"%@aaa",x);
    }];

    // 信号的信号发送信号
    [signalOfsignals sendNext:signal];

    // 信号发送内容
    [signal sendNext:@1];
</code></pre>

<ul>
<li><p>1.5 ReactiveCocoa操作方法之组合。</p>
<ul>
<li><p><code>concat</code>:按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。</p>
<pre><code>
RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  [subscriber sendCompleted];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活。
RACSignal *concatSignal = [signalA concat:signalB];
// 以后只需要面对拼接信号开发。
// 订阅拼接的信号，不需要单独订阅signalA，signalB
// 内部会自动订阅。
// 注意：第一个信号必须发送完成，第二个信号才会被激活
[concatSignal subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
// concat底层实现:
// 1.当拼接信号被订阅，就会调用拼接信号的didSubscribe
// 2.didSubscribe中，会先订阅第一个源信号（signalA）
// 3.会执行第一个源信号（signalA）的didSubscribe
// 4.第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来.
// 5.第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。
// 6.订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe
// 7.第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来.
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>then</code>:用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</p>
<pre><code>
// then:用于连接两个信号，当第一个信号完成，才会连接then返回的信号
// 注意使用then，之前信号的值会被忽略掉.
// 底层实现：1、先过滤掉之前的信号发出的值。2.使用concat连接then返回的信号
[[[RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  [subscriber sendCompleted];
  return nil;
}] then:^RACSignal *{
  return [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
      [subscriber sendNext:@2];
      return nil;
  }];
}] subscribeNext:^(id x) {
  // 只能接收到第二个信号的值，也就是then返回信号的值
  NSLog(@"%@",x);
}];
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>merge</code>:把多个信号合并为一个信号，任何一个信号有新值的时候就会调用.</p>
<pre><code>
// merge:把多个信号合并成一个信号
//创建多个信号
RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 合并信号,任何一个信号发送数据，都能监听到.
RACSignal *mergeSignal = [signalA merge:signalB];
[mergeSignal subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
// 底层实现：
// 1.合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。
// 2.每发出一个信号，这个信号就会被订阅
// 3.也就是合并信号一被订阅，就会订阅里面所有的信号。
// 4.只要有一个信号被发出就会被监听。
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>zipWith</code>:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。</p>
<pre><code>
RACSignal *signalA = [RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 压缩信号A，信号B
RACSignal *zipSignal = [signalA zipWith:signalB];
[zipSignal subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
// 底层实现:
// 1.定义压缩信号，内部就会自动订阅signalA，signalB
// 2.每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把最近发出的信号都包装成元组发出。
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>combineLatest</code>:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</p>
<pre><code>
RACSignal *signalA = [RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 把两个信号组合成一个信号,跟zip一样，没什么区别
RACSignal *combineSignal = [signalA combineLatestWith:signalB];
[combineSignal subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
// 底层实现：
// 1.当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。
// 2.并且把两个信号组合成元组发出。
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>reduce</code>聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值</p>
<pre><code>
RACSignal *signalA = [RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 聚合
// 常见的用法，（先组合在聚合）。combineLatest:(id<nsfastenumeration>)signals reduce:(id (^)())reduceBlock
// reduce中的block简介:
// reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容
// reduceblcok的返回值：聚合信号之后的内容。
RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2){
 return [NSString stringWithFormat:@"%@ %@",num1,num2];
}];
[reduceSignal subscribeNext:^(id x) {

  NSLog(@"%@",x);
}];
// 底层实现:
// 1.订阅聚合信号，每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。
</nsfastenumeration></racsubscriber></racsubscriber></code></pre>
</li>
</ul>
</li>
<li><p>1.6 ReactiveCocoa操作方法之过滤。    </p>
<ul>
<li><p><code>filter</code>:过滤信号，使用它可以获取满足条件的信号.</p>
<pre><code>
// 过滤:
// 每次信号发出，会先执行过滤条件判断.
[_textField.rac_textSignal filter:^BOOL(NSString *value) {
    return value.length > 3;
}];
</code></pre>
</li>
<li><p><code>ignore</code>:忽略完某些值的信号. </p>
<pre><code>
// 内部调用filter过滤，忽略掉ignore的值
[[_textField.rac_textSignal ignore:@"1"] subscribeNext:^(id x) {
NSLog(@"%@",x);
}];
</code></pre>
</li>
<li><p><code>distinctUntilChanged</code>:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</p>
<pre><code>
// 过滤，当上一次和当前的值不一样，就会发出内容。
// 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新
[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) {
NSLog(@"%@",x);
}];
</code></pre>
</li>
<li><p><code>take</code>:从开始一共取N次的信号</p>
<pre><code>
   // 1、创建信号
  RACSubject *signal = [RACSubject subject];
  // 2、处理信号，订阅信号
  [[signal takeLast:1] subscribeNext:^(id x) {
    NSLog(@"%@",x);
  }];
  // 3.发送信号
  [signal sendNext:@1];
  [signal sendNext:@2];
  [signal sendCompleted];
</code></pre>
</li>
<li><p><code>skip</code>:(NSUInteger):跳过几个信号,不接受。</p>
<pre><code>
   // 表示输入第一次，不会被监听到，跳过第一次发出的信号
    [[_textField.rac_textSignal skip:1] subscribeNext:^(id x) {
        NSLog(@"%@",x);
    }];
</code></pre>
</li>
<li><p><code>switchToLatest</code>:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</p>
<pre><code>
   RACSubject *signalOfSignals = [RACSubject subject];
  RACSubject *signal = [RACSubject subject];
  [signalOfSignals sendNext:signal];
  [signal sendNext:@1];
  // 获取信号中信号最近发出信号，订阅最近发出的信号。
  // 注意switchToLatest：只能用于信号中的信号
  [signalOfSignals.switchToLatest subscribeNext:^(id x) {
   NSLog(@"%@",x);
  }];
</code></pre>
</li>
</ul>
</li>
<li><p>1.7 ReactiveCocoa操作方法之秩序.</p>
<ul>
<li><code>doNext</code>: 执行Next之前，会先执行这个Block</li>
<li><code>doCompleted</code>: 执行sendCompleted之前，会先执行这个Block<pre><code>
[[[[RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
[subscriber sendNext:@1];
[subscriber sendCompleted];
return nil;
}] doNext:^(id x) {
// 执行[subscriber sendNext:@1];之前会调用这个Block
NSLog(@"doNext");;
}] doCompleted:^{
 // 执行[subscriber sendCompleted];之前会调用这个Block
NSLog(@"doCompleted");;
}] subscribeNext:^(id x) {
NSLog(@"%@",x);
}];
</racsubscriber></code></pre>
</li>
</ul>
</li>
<li><p>1.8 ReactiveCocoa操作方法之线程。    </p>
<ul>
<li><code>deliverOn</code>: 内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。</li>
<li><code>subscribeOn</code>: 内容传递和副作用都会切换到制定线程中。</li>
</ul>
</li>
<li><p>1.9 ReactiveCocoa操作方法之时间。</p>
<ul>
<li><p><code>timeout</code>：超时，可以让一个信号在一定的时间后，自动报错。</p>
<pre><code>
RACSignal *signal = [[RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
return nil;
}] timeout:1 onScheduler:[RACScheduler currentScheduler]];
[signal subscribeNext:^(id x) {
NSLog(@"%@",x);
} error:^(NSError *error) {
// 1秒后会自动调用
NSLog(@"%@",error);
}];
</racsubscriber></code></pre>
</li>
<li><p><code>interval</code> 定时：每隔一段时间发出信号</p>
<pre><code>
[[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) {
   NSLog(@"%@",x);
}];
</code></pre>
</li>
<li><p><code>delay</code> 延迟发送next。</p>
<pre><code>
RACSignal *signal = [[[RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
[subscriber sendNext:@1];
   return nil;
}] delay:2] subscribeNext:^(id x) {
   NSLog(@"%@",x);
}];
</racsubscriber></code></pre>
</li>
</ul>
</li>
<li><p>1.9 ReactiveCocoa操作方法之重复。</p>
<ul>
<li><p><code>retry</code>重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</p>
<pre><code>
__block int i = 0;
[[[RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  if (i == 10) {
      [subscriber sendNext:@1];
  }else{
      NSLog(@"接收到错误");
      [subscriber sendError:nil];
  }
  i++;
  return nil;
}] retry] subscribeNext:^(id x) {
  NSLog(@"%@",x);
} error:^(NSError *error) {
}];
</racsubscriber></code></pre>
</li>
<li><p><code>replay</code>重放：当一个信号被多次订阅,反复播放内容</p>
<pre><code>
RACSignal *signal = [[RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
     [subscriber sendNext:@1];
     [subscriber sendNext:@2];
     return nil;
}] replay];
[signal subscribeNext:^(id x) {
     NSLog(@"第一个订阅者%@",x);
}];
[signal subscribeNext:^(id x) {
     NSLog(@"第二个订阅者%@",x);
}];
</racsubscriber></code></pre>
</li>
<li><p><code>throttle</code>节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p>
<pre><code>
RACSubject *signal = [RACSubject subject];
_signal = signal;
// 节流，在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。
[[signal throttle:1] subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
</code></pre>




</li>
</ul>
</li>
</ul>
<h3 id="2-介绍MVVM架构思想。"><a href="#2-介绍MVVM架构思想。" class="headerlink" title="2.介绍MVVM架构思想。"></a>2.介绍MVVM架构思想。</h3><ul>
<li>2.1 程序为什么要架构：便于程序员开发和维护代码</li>
<li>2.2 常见的架构思想:<ul>
<li><code>MVC</code> M:模型 V:视图 C:控制器</li>
<li><code>MVVM</code> M:模型 V:视图+控制器 VM:视图模型</li>
<li><code>MVCS</code> M:模型 V:视图 C:控制器 C:服务类</li>
<li><code>VIPER</code> V:视图 I:交互器 P:展示器 E:实体 R:路由 (<a href="http://www.cocoachina.com/ios/20140703/9016.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20140703/9016.html</a>)</li>
</ul>
</li>
<li>2.3 MVVM介绍<ul>
<li><code>模型</code>(M):保存视图数据。</li>
<li><code>视图+控制器</code>(V):展示内容 + 如何展示</li>
<li><code>视图模型</code>(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。</li>
</ul>
</li>
</ul>
<h3 id="3-ReactiveCocoa-MVVM-实战一：登录界面"><a href="#3-ReactiveCocoa-MVVM-实战一：登录界面" class="headerlink" title="3.ReactiveCocoa + MVVM 实战一：登录界面"></a>3.ReactiveCocoa + MVVM 实战一：登录界面</h3><ul>
<li><p>3.1 需求+分析+步骤</p>
<pre><code>
  /* 需求：1.监听两个文本框的内容，有内容才允许按钮点击
      2.默认登录请求.

 用MVVM：实现，之前界面的所有业务逻辑
 分析：1.之前界面的所有业务逻辑都交给控制器做处理
      2.在MVVM架构中把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型.

 步骤：1.创建LoginViewModel类，处理登录界面业务逻辑.
      2.这个类里面应该保存着账号的信息，创建一个账号Account模型
      3.LoginViewModel应该保存着账号信息Account模型。
      4.需要时刻监听Account模型中的账号和密码的改变，怎么监听？
      5.在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。
      6.每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号.
      7.这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号.
      8.监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑.
      9.执行命令，把数据包装成信号传递出去
      10.监听命令中信号的数据传递
      11.监听命令的执行时刻
*/
</code></pre>
</li>
<li><p>3.2 控制器的代码</p>
<pre><code>
  @interface ViewController ()
  @property (nonatomic, strong) LoginViewModel *loginViewModel;
  @property (weak, nonatomic) IBOutlet UITextField *accountField;
  @property (weak, nonatomic) IBOutlet UITextField *pwdField;
  @property (weak, nonatomic) IBOutlet UIButton *loginBtn;
  @end
  - (LoginViewModel *)loginViewModel
  {
      if (_loginViewModel == nil) {
          _loginViewModel = [[LoginViewModel alloc] init];
      }
      return _loginViewModel;
  }
  // 视图模型绑定
  - (void)bindModel
  {
      // 给模型的属性绑定信号
      // 只要账号文本框一改变，就会给account赋值
      RAC(self.loginViewModel.account, account) = _accountField.rac_textSignal;
      RAC(self.loginViewModel.account, pwd) = _pwdField.rac_textSignal;
      // 绑定登录按钮
      RAC(self.loginBtn,enabled) = self.loginViewModel.enableLoginSignal;
     // 监听登录按钮点击
      [[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {
          // 执行登录事件
          [self.loginViewModel.LoginCommand execute:nil];
      }];
  }
</code></pre>
</li>
<li><p>3.3 VM的代码</p>
<pre><code>
  @interface LoginViewModel : NSObject
  @property (nonatomic, strong) Account *account;
  // 是否允许登录的信号
  @property (nonatomic, strong, readonly) RACSignal *enableLoginSignal;
  @property (nonatomic, strong, readonly) RACCommand *LoginCommand;
  @end
  @implementation LoginViewModel
  - (Account *)account
  {
      if (_account == nil) {
          _account = [[Account alloc] init];
      }
      return _account;
  }
  - (instancetype)init
  {
      if (self = [super init]) {
          [self initialBind];
      }
      return self;
  }
  // 初始化绑定
  - (void)initialBind
  {
      // 监听账号的属性值改变，把他们聚合成一个信号。
      _enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.account, account),RACObserve(self.account, pwd)] reduce:^id(NSString *account,NSString *pwd){
          return @(account.length && pwd.length);
      }];
      // 处理登录业务逻辑
      _LoginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
          NSLog(@"点击了登录");
          return [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
              // 模仿网络延迟
              dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                  [subscriber sendNext:@"登录成功"];
                  // 数据传送完毕，必须调用完成，否则命令永远处于执行状态
                  [subscriber sendCompleted];
              });
              return nil;
          }];
      }];
      // 监听登录产生的数据
      [_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) {
          if ([x isEqualToString:@"登录成功"]) {
              NSLog(@"登录成功");
          }
      }];
      // 监听登录状态
      [[_LoginCommand.executing skip:1] subscribeNext:^(id x) {
          if ([x isEqualToNumber:@(YES)]) {
              // 正在登录ing...
              // 用蒙版提示
              [MBProgressHUD showMessage:@"正在登录..."];
          }else
          {
              // 登录成功
              // 隐藏蒙版
              [MBProgressHUD hideHUD];
          }
      }];
  }
</racsubscriber></code></pre>


</li>
</ul>
<h3 id="4-ReactiveCocoa-MVVM-实战二：网络请求数据"><a href="#4-ReactiveCocoa-MVVM-实战二：网络请求数据" class="headerlink" title="4.ReactiveCocoa + MVVM 实战二：网络请求数据"></a>4.ReactiveCocoa + MVVM 实战二：网络请求数据</h3><ul>
<li>4.1 接口：这里先给朋友介绍一个免费的网络数据接口，豆瓣。可以经常用来练习一些网络请求的小Demo.</li>
<li><p>4.2 需求+分析+步骤</p>
<pre><code>
/*
  需求：请求豆瓣图书信息，url:https://api.douban.com/v2/book/search?q=基础

  分析：请求一样，交给VM模型管理

  步骤:
      1.控制器提供一个视图模型（requesViewModel），处理界面的业务逻辑
      2.VM提供一个命令，处理请求业务逻辑
      3.在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。
      4.请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中获取。
      5.假设控制器想展示内容到tableView，直接让视图模型成为tableView的数据源，把所有的业务逻辑交给视图模型去做，这样控制器的代码就非常少了。
*/
</code></pre>
</li>
<li><p>4.3 控制器代码</p>
<pre><code>
  @interface ViewController ()
  @property (nonatomic, weak) UITableView *tableView;
  @property (nonatomic, strong) RequestViewModel *requesViewModel;
  @end
  @implementation ViewController
  - (RequestViewModel *)requesViewModel
  {
      if (_requesViewModel == nil) {
          _requesViewModel = [[RequestViewModel alloc] init];
      }
      return _requesViewModel;
  }
  - (void)viewDidLoad {
      [super viewDidLoad];
      // Do any additional setup after loading the view, typically from a nib.
      // 创建tableView
      UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
      tableView.dataSource = self.requesViewModel;
      self.requesViewModel.tableView = tableView;
      [self.view addSubview:tableView];
      // 执行请求
      [self.requesViewModel.reuqesCommand execute:nil];

  }
  @end
</code></pre>
</li>
<li><p>4.4 视图模型(VM)代码</p>
<pre><code>
  @interface RequestViewModel : NSObject<uitableviewdatasource>
  // 请求命令
  @property (nonatomic, strong, readonly) RACCommand *reuqesCommand;
  //模型数组
  @property (nonatomic, strong, readonly) NSArray *models;
  // 控制器中的view
  @property (nonatomic, weak) UITableView *tableView;
  @end
  @implementation RequestViewModel
  - (instancetype)init
  {
      if (self = [super init]) {
          [self initialBind];
      }
      return self;
  }
  - (void)initialBind
  {
      _reuqesCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
          RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
              NSMutableDictionary *parameters = [NSMutableDictionary dictionary];
              parameters[@"q"] = @"基础";
              // 发送请求
              [[AFHTTPRequestOperationManager manager] GET:@"https://api.douban.com/v2/book/search" parameters:parameters success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
                  NSLog(@"%@",responseObject);
                  // 请求成功调用
                  // 把数据用信号传递出去
                  [subscriber sendNext:responseObject];
                  [subscriber sendCompleted];
              } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {
                  // 请求失败调用
              }];
              return nil;
          }];
          // 在返回数据信号时，把数据中的字典映射成模型信号，传递出去
          return [requestSignal map:^id(NSDictionary *value) {
              NSMutableArray *dictArr = value[@"books"];
              // 字典转模型，遍历字典中的所有元素，全部映射成模型，并且生成数组
              NSArray *modelArr = [[dictArr.rac_sequence map:^id(id value) {
                  return [Book bookWithDict:value];
              }] array];
              return modelArr;
          }];
      }];
      // 获取请求的数据
      [_reuqesCommand.executionSignals.switchToLatest subscribeNext:^(NSArray *x) {
          // 有了新数据，刷新表格
          _models = x;
          // 刷新表格
          [self.tableView reloadData];
      }];
  }
  #pragma mark - UITableViewDataSource
  - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
  {
      return self.models.count;
  }
  - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
  {
      static NSString *ID = @"cell";
      UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
      if (cell == nil) {

          cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];
      }
      Book *book = self.models[indexPath.row];
      cell.detailTextLabel.text = book.subtitle;
      cell.textLabel.text = book.title;
      return cell;
  }
  @end
</racsubscriber></uitableviewdatasource></code></pre>    


</li>
</ul>
<!-- more -->]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS动画篇之UIView动画]]></title>
      <url>http://yoursite.com/2016/03/04/iOS%E5%8A%A8%E7%94%BB%E7%AF%87-transfrom/</url>
      <content type="html"><![CDATA[<p>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持。<br><a id="more"></a></p>
<h4 id="UIViewAnimationOptions参考"><a href="#UIViewAnimationOptions参考" class="headerlink" title="UIViewAnimationOptions参考"></a>UIViewAnimationOptions参考</h4><pre><code>
1.基本类型
UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。
UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。
UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。
UIViewAnimationOptionRepeat：重复运行动画。
UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。
UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。
UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。
UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。  
UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）
UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。

2.动画速度控制（可从其中选择一个设置）
UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。
UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。
UIViewAnimationOptionCurveEaseOut：动画逐渐加速。
UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。

3.转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）
UIViewAnimationOptionTransitionNone：没有转场动画效果。
UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。
UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。
UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。    
UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。    
UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。    
UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。    
UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。
</code></pre>


<h3 id="1-基本动画"><a href="#1-基本动画" class="headerlink" title="1. 基本动画"></a>1. 基本动画</h3><p><code>+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<pre><code>
duration   :   持续时间  
delay      :   延迟执行  
options    :   动画选项(往复、循环等)  
animations :   动画block  
completion :   完成后的block 
</code></pre>

<ul>
<li><strong>可实现动画的属性</strong></li>
</ul>
<pre><code>
坐标尺寸类: bounds、frame、center  
视图显示类: backgroundColor、alpha、hidden  
形态变化类: transform
</code></pre>

<h3 id="2-弹簧动画"><a href="#2-弹簧动画" class="headerlink" title="2.弹簧动画"></a>2.弹簧动画</h3><p><code>+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">usingSpringWithDamping   :   0.0 ~ 1.0 阻尼比例，数值越小「弹簧」的振动效果越明显</div><div class="line">initialSpringVelocity    :   初始的速度，数值越大一开始移动越快</div></pre></td></tr></table></figure>
<h3 id="3-过渡动画"><a href="#3-过渡动画" class="headerlink" title="3.过渡动画"></a>3.过渡动画</h3><p><code>+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<pre><code>
view       :   需要进行转场动画的视图
options    :   转场动画的类型
</code></pre>

<p><code>+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<pre><code>
方法调用完毕后，相当于执行了下面两句代码：
// 添加toView到父视图
[fromView.superview addSubview:toView];
// 把fromView从父视图中移除
[fromView removeFromSuperview];
</code></pre>

<h3 id="4-keyframe动画"><a href="#4-keyframe动画" class="headerlink" title="4. keyframe动画"></a>4. keyframe动画</h3><p><code>+ (void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<p><code>+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RelativeStartTime : 关键帧动画开始时间的比例值</div><div class="line">RelativeDuration  : 关键帧动画持续实践的比例值</div></pre></td></tr></table></figure>
<ul>
<li><strong>用法示例:</strong></li>
</ul>
<pre><code>
[UIView animateKeyframesWithDuration:8 delay:0 options:UIViewKeyframeAnimationOptionCalculationModeLinear animations:^{
        [UIView addKeyframeWithRelativeStartTime:0 relativeDuration:0.25 animations:^{
            self.imgV.center = (CGPoint){center.x + 200 ,center.y + 150};
        }];
        [UIView addKeyframeWithRelativeStartTime:0.25 relativeDuration:0.25 animations:^{
            self.imgV.center = (CGPoint){center.x ,center.y + 300};
        }];
        [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.25 animations:^{
            self.imgV.center = (CGPoint){center.x + 200,center.y + 450};
        }];
        [UIView addKeyframeWithRelativeStartTime:0.75 relativeDuration:0.25 animations:^{
            self.imgV.center = (CGPoint){center.x + 0,center.y + 600 };
        }];
    } completion:nil];
</code></pre>

<h3 id="5-transform变换"><a href="#5-transform变换" class="headerlink" title="5. transform变换"></a>5. transform变换</h3><p><code>CGAffineTransform</code></p>
<ul>
<li><strong>变换原理</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct CGAffineTransform &#123;</div><div class="line">   CGFloat a;</div><div class="line">   CGFloat b;</div><div class="line">   CGFloat c;</div><div class="line">   CGFloat d;</div><div class="line">   CGFloat tx;</div><div class="line">   CGFloat ty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>结构体矩阵图为：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_26.gif?raw=true" alt="矩阵图"><br></div>

<p>因为最后一列总是是(0,0,1)，所以有用的信息就是前面两列<br>对一个view进行仿射变化就相当于对view上的每个点做一个乘法<br>结果就是：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_27.gif?raw=true" alt="映射变换"><br></div>

<p><strong>相当于：</strong><br>(x, y, 1 ) –&gt; (ax + cy + tx, bx + dy + ty, 1) </p>
<p>如果不看c和b的话<br>a表示x水平方向的缩放，tx表示x水平方向的偏移<br>d表示y垂直方向的缩放，ty表示y垂直方向的偏移<br>如果b和c不为零的话，那么视图肯定发生了旋转</p>
<p><strong>常量</strong><br>CGAffineTransformIdentity<br>CGAffineTransform<br>CGAffineTransformIdentity;<br>这个就是没有变化的最初的样子 </p>
<ul>
<li><strong>常用函数</strong></li>
</ul>
<pre><code>
/// 用来连接两个变换效果并返回。返回的t = t1 * t2
CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2)

/// 矩阵初始值。[ 1 0 0 1 0 0 ]
CGAffineTransformIdentity

/// 自定义矩阵变换，需要掌握矩阵变换的知识才知道怎么用。参照(x, y, 1 ) --> (ax + cy + tx, bx + dy + ty, 1)  
CGAffineTransformMake(CGFloat a, CGFloat b, CGFloat c, CGFloat d, CGFloat tx, CGFloat ty)

/// 旋转视图。传入参数为 角度 * (M_PI / 180)。等同于 CGAffineTransformRotate(self.transform, angle)
CGAffineTransformMakeRotation(CGFloat angle)
CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)

/// 缩放视图。等同于CGAffineTransformScale(self.transform, sx, sy)
CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)

/// 缩放视图。等同于CGAffineTransformTranslate(self.transform, tx, ty)
CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)
CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)
</code></pre>

<ul>
<li><strong>常用函数</strong></li>
</ul>
<pre><code>
- (void)viewDidAppear:(BOOL)animated {
    CGFloat offset = self.label1.frame.size.height * 0.5;

    self.label1.transform = CGAffineTransformConcat(
                                                    CGAffineTransformMakeScale(1, 0),
                                                    CGAffineTransformMakeTranslation(0, -offset));

    self.label1.alpha = 0;
    [UIView animateWithDuration:3.0 animations:^{
        self.label1.transform = CGAffineTransformIdentity;
        self.label1.alpha = 1;

        self.label2.transform = CGAffineTransformConcat(
                                                        CGAffineTransformMakeScale(1, 0.1),
                                                        CGAffineTransformMakeTranslation(0, offset));
        self.label2.alpha = 0;
    }];
}
</code></pre>


<h3 id="6-UIView动画（首尾方式）"><a href="#6-UIView动画（首尾方式）" class="headerlink" title="6.UIView动画（首尾方式）"></a>6.UIView动画（首尾方式）</h3><p>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持<br>执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间</p>
<p>常见方法解析:<br>　　<strong>+ (void)setAnimationDelegate:(id)delegate</strong>     设置动画代理对象，当动画开始或者结束时会发消息给代理对象<br>　　<strong>+ (void)setAnimationWillStartSelector:(SEL)selector</strong>   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector<br>　　<strong>+ (void)setAnimationDidStopSelector:(SEL)selector</strong>  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector<br>　　<strong>+ (void)setAnimationDuration:(NSTimeInterval)duration</strong>   动画的持续时间，秒为单位<br>　　<strong>+ (void)setAnimationDelay:(NSTimeInterval)delay</strong>  动画延迟delay秒后再开始<br>　　<strong>+ (void)setAnimationStartDate:(NSDate *)startDate</strong>   动画的开始时间，默认为now<br>　　<strong>+ (void)setAnimationCurve:(UIViewAnimationCurve)curve</strong>  动画的节奏控制<br>　　<strong>+ (void)setAnimationRepeatCount:(float)repeatCount</strong>  动画的重复次数<br>　　<strong>+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses</strong>  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反<br>　　<strong>+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache</strong>  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</p>
<p><strong>代码示例: </strong></p>
<pre><code>
@interface ViewController ()
@property (weak, nonatomic) IBOutlet UIView *customView;


@end

@implementation YYViewController

- (void)viewDidLoad
{
     [super viewDidLoad];

}

-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
     //打印动画块的位置
     NSLog(@"动画执行之前的位置：%@",NSStringFromCGPoint(self.customView.center));

     //首尾式动画
     [UIView beginAnimations:nil context:nil];
     //执行动画
     //设置动画执行时间
     [UIView setAnimationDuration:2.0];
     //设置代理
     [UIView setAnimationDelegate:self];
     //设置动画执行完毕调用的事件
     [UIView setAnimationDidStopSelector:@selector(didStopAnimation)];
     self.customView.center=CGPointMake(200, 300);
     [UIView commitAnimations];

}

-(void)didStopAnimation
{
     NSLog(@"动画执行完毕");
     //打印动画块的位置
     NSLog(@"动画执行之后的位置：%@",NSStringFromCGPoint(self.customView.center));
}
@end
</code></pre>

<p><strong>说明:</strong><br>　　使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。</p>
<p>CALayer核心动画与UIView动画的区别：<br>　　<strong>UIView封装的动画执行完毕之后不会反弹。即如果是通过CALayer核心动画改变layer的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</strong></p>
<h3 id="7-补充"><a href="#7-补充" class="headerlink" title="7.补充"></a>7.补充</h3><h5 id="UIImageView的帧动画"><a href="#UIImageView的帧动画" class="headerlink" title="UIImageView的帧动画"></a>UIImageView的帧动画</h5><p>UIImageView可以让一系列的图片在特定的时间内按顺序显示</p>
<p>相关属性解析:<br>　　<strong>animationImages</strong>：要显示的图片(一个装着UIImage的NSArray)<br>　　<strong>animationDuration</strong>：完整地显示一次animationImages中的所有图片所需的时间<br>　　<strong>animationRepeatCount</strong>：动画的执行次数(默认为0，代表无限循环)</p>
<p>相关方法解析:<br>　　<strong>- (void)startAnimating</strong>; 开始动画<br>　　<strong>- (void)stopAnimating</strong>;  停止动画<br>　　<strong>- (BOOL)isAnimating</strong>;  是否正在运行动画</p>
<h5 id="UIActivityIndicatorView"><a href="#UIActivityIndicatorView" class="headerlink" title="UIActivityIndicatorView"></a>UIActivityIndicatorView</h5><p>是一个旋转进度轮，可以用来告知用户有一个操作正在进行中，一般用initWithActivityIndicatorStyle初始化</p>
<p>相关方法解析:<br>　　<strong>- (void)startAnimating</strong>; 开始动画<br>　　<strong>- (void)stopAnimating</strong>;  停止动画<br>　　<strong>- (BOOL)isAnimating</strong>;  是否正在运行动画</p>
<p>UIActivityIndicatorViewStyle有3个值可供选择：<br>　　<strong>UIActivityIndicatorViewStyleWhiteLarge</strong>   //大型白色指示器<br>　　<strong>UIActivityIndicatorViewStyleWhite</strong>      //标准尺寸白色指示器<br>　　<strong>UIActivityIndicatorViewStyleGray</strong>    //灰色指示器，用于白色背景</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS动画篇之CoreAnimation动画]]></title>
      <url>http://yoursite.com/2016/02/27/iOS%E5%8A%A8%E7%94%BB%E7%AF%87%E4%B9%8BCoreAnimation%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p>App如果想被大众喜欢，漂亮的UI和精美的动画都是必不可少的，苹果虽然为UIView提供了一些常用动画，但是大部分看起来比较不错的效果都是通过操作Layer层实现的，因此了解核心动画是必要的.CoreAnimation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。<br><a id="more"></a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>开发中用的最多的是<code>CoreAnimation</code>动画库，简称是CA，所以动画类都是CA开头。所有的动画类都在<code>QuartzCore</code>库中，在iOS7之前使用需要<code>#import &lt;QuartzCore/QuartzCore.h&gt;</code>,iOS7之后系统已经将其自动导入了。<code>CoreAnimation</code>动画都是作用在<code>layer</code>上。<br>先来看下动画类的层级关系：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_12.png?raw=true" alt="动画层级结构"><br></div><br>关于上图中的层级结构只需要了解一下，用的多了，自然就记住了。本篇只讲述<code>CABasicAnimation</code>、<code>CAKeyframeAnimation</code>、<code>CAAnimationGroup</code>的使用。<br><br>### 使用<br>上面讲了CA动画都是作用在Layer上，而CA动画中修改的也是Layer的动画属性，可以产生动画的layer属性也有<code>Animatable</code>标识。<br>#### 1.CABasicAnimation<br><code>CABasicAnimation</code>动画主要是设置某个动画属性的初始值fromValue和结束值toValue，来产生动画效果。<br>先上个示例代码，将一个视图往上移动一段距离：<br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_13.gif?raw=true" alt="animation"><br></div>

<pre><code>
CABasicAnimation *postionAnimation = [CABasicAnimation animationWithKeyPath:@"position.y"];
postionAnimation.duration = 1.0f;
postionAnimation.fromValue = @(self.squareView.center.y);
postionAnimation.toValue = @(self.squareView.center.y - 300);
postionAnimation.removedOnCompletion = NO;
postionAnimation.delegate = self;
postionAnimation.autoreverses = YES;
postionAnimation.fillMode = kCAFillModeForwards;
postionAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
[self.squareView.layer addAnimation:postionAnimation forKey:@"posstionAnimation"];
</code></pre>

<blockquote>
<ul>
<li>动画的创建使用<code>animationWithKeyPath:</code>,因为使用的keyPath所以动画属性或者其结构体中元素都可以产生动画。</li>
<li><code>duration</code> 动画的时长。</li>
<li><code>fromValue</code>和<code>toValue</code> 是<code>CABasicAnimation</code>的属性，都是id类型的，所以要将基本类型包装成对象。</li>
<li><code>removedOnCompletion</code> 决定动画执行完之后是否将该动画的影响移除，默认是YES,则layer回到动画前的状态。</li>
<li><code>fillMode</code> 是个枚举值（四种），当<code>removedOnCompletion</code>设置为NO之后才会起作用。可以设置layer是保持动画开始前的状态还是动画结束后的状态，或是其他的。</li>
<li><code>autoreverses</code> 表示动画结束后是否 backwards(回退) 到动画开始前的状态。可与上面两个属性组合出不同效果。</li>
<li><code>timingFunction</code> 动画的运动是匀速线性的还是先快后慢等，类似UIView动画的opitions。另外，CAMediaTimingFunction 方法可以自定义。</li>
<li><code>delegate</code> 代理，两个动画代理方法：<code>- (void)animationDidStart:(CAAnimation *)anim</code>; 和<code>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</code>;</li>
<li><code>-(void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key</code>; 给某个layer添加动画，与之对应的移除某个动画是<code>- (void)removeAnimationForKey:(NSString *)key</code>;</li>
<li>还有一些其他的属性，就不一一介绍了，可以在使用的使用去.h文件中查看。</li>
</ul>
</blockquote>
<p>在这里简单介绍一下fillMode<br>注意：fillMode这个属性，必须要配合下面这个属性来使用。这个属性的默认值是YES(回到原处),此时fillMode是没有作用的如果设置为NO那么就需要设置一个fillMode属性，就是动画结束之后的状态，如果不设置，动画也会回到原处。</p>
<p><code>postionAnimation.removedOnCompletion = NO;</code></p>
<pre><code>
kCAFillModeRemoved 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态 
kCAFillModeForwards 当动画结束后,layer会一直保持着动画最后的状态 
kCAFillModeBackwards 这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了
一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个
layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初
始状态 
kCAFillModeBoth 理解了上面两个,这个就很好理解了,这个其实就是上面两个的合成.动画加入后开始之
前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.</code></pre>    


<h5 id="Rotation旋转"><a href="#Rotation旋转" class="headerlink" title="Rotation旋转"></a>Rotation旋转</h5><ul>
<li><strong>Z轴</strong></li>
</ul>
<pre><code>
CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation"];
rotationAnimation.fromValue = [NSNumber numberWithFloat:0.0];
rotationAnimation.toValue = [NSNumber numberWithFloat:2*M_PI];
rotationAnimation.repeatCount = MAXFLOAT;
rotationAnimation.duration =10;
[self.rotationImgView.layer addAnimation:rotationAnimation forKey:@"transform.rotation.z"];
</code></pre>

<ul>
<li><strong>X轴</strong></li>
</ul>
<pre><code>
CABasicAnimation *rotationXAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.x"];
rotationXAnimation.fromValue = [NSNumber numberWithFloat:0.0];
rotationXAnimation.toValue = [NSNumber numberWithFloat:2*M_PI];
rotationXAnimation.repeatCount = MAXFLOAT;
rotationXAnimation.duration =3;
[self.rotationXImgView.layer addAnimation:rotationXAnimation forKey:@"transform.rotation.x"];
</code></pre>

<ul>
<li><strong>Y轴</strong></li>
</ul>
<pre><code>
CABasicAnimation *rotationYAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"];
rotationYAnimation.fromValue = [NSNumber numberWithFloat:0.0];
rotationYAnimation.toValue = [NSNumber numberWithFloat:2*M_PI];
rotationYAnimation.repeatCount = MAXFLOAT;
rotationYAnimation.duration =10;
[self.rotationYImgView.layer addAnimation:rotationYAnimation forKey:@"transform.rotation.y"];
</code></pre>

<h5 id="Scale放大缩小"><a href="#Scale放大缩小" class="headerlink" title="Scale放大缩小"></a>Scale放大缩小</h5><ul>
<li><strong>任意方向放大</strong></li>
</ul>
<pre><code>
CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];
scaleAnimation.fromValue = [NSNumber numberWithFloat:1.0];
scaleAnimation.toValue = [NSNumber numberWithFloat:1.5];
scaleAnimation.autoreverses = YES;//自动反向执行动画效果
scaleAnimation.repeatCount = MAXFLOAT;
scaleAnimation.duration = 0.8;
[self.scaleImgView.layer addAnimation:scaleAnimation forKey:@"FlyElephant.scale"];
</code></pre>

<ul>
<li><strong>X轴放大</strong></li>
</ul>
<pre><code>
CABasicAnimation *scaleXAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale.x"];
scaleXAnimation.fromValue = [NSNumber numberWithFloat:1.0];
scaleXAnimation.toValue = [NSNumber numberWithFloat:1.5];
scaleXAnimation.autoreverses = YES;//自动反向执行动画效果
scaleXAnimation.repeatCount = MAXFLOAT;
scaleXAnimation.duration = 0.8;
[self.scaleXImgView.layer addAnimation:scaleXAnimation forKey:@"FlyElephant.scale.x"];
</code></pre>

<ul>
<li><strong>Y轴放大</strong></li>
</ul>
<pre><code>
CABasicAnimation *scaleYAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale.y"];
scaleYAnimation.fromValue = [NSNumber numberWithFloat:1.0];
scaleYAnimation.toValue = [NSNumber numberWithFloat:1.5];
scaleYAnimation.autoreverses = YES;//自动反向执行动画效果
scaleYAnimation.repeatCount = MAXFLOAT;
scaleYAnimation.duration = 0.8;
[self.scaleYImgView.layer addAnimation:scaleYAnimation forKey:@"FlyElephant.scale.y"];
</code></pre>

<ul>
<li><strong>Z轴放大</strong></li>
</ul>
<pre><code>
CABasicAnimation *scaleZAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale.z"];
scaleZAnimation.fromValue = [NSNumber numberWithFloat:1.0];
scaleZAnimation.toValue = [NSNumber numberWithFloat:1.5];
scaleZAnimation.autoreverses = YES;//自动反向执行动画效果
scaleZAnimation.repeatCount = MAXFLOAT;
scaleZAnimation.duration = 0.8;
[self.scaleZImgView.layer addAnimation:scaleZAnimation forKey:@"FlyElephant.scale.z"];
</code></pre>

<h5 id="Translation平移"><a href="#Translation平移" class="headerlink" title="Translation平移"></a>Translation平移</h5><ul>
<li><strong>X轴平移</strong></li>
</ul>
<pre><code>
CABasicAnimation *translationX=[CABasicAnimation animationWithKeyPath:@"transform.translation.x"];
translationX.toValue=@(200);
translationX.duration=5;
translationX.removedOnCompletion=NO;
translationX.fillMode=kCAFillModeForwards;
translationX.repeatCount=MAXFLOAT;
translationX.autoreverses=YES;
[self.translationXImgView.layer addAnimation:translationX forKey:@"FlyElephant.translation.x"];

</code></pre>

<ul>
<li><strong>Y轴平移</strong></li>
</ul>
<pre><code>
CABasicAnimation *translationY=[CABasicAnimation animationWithKeyPath:@"transform.translation.y"];
translationY.toValue=@(100);
translationY.duration=5;
translationY.removedOnCompletion=NO;
translationY.fillMode=kCAFillModeForwards;
translationY.repeatCount=MAXFLOAT;
translationY.autoreverses=YES;
[self.translationYImgView.layer addAnimation:translationY forKey:@"FlyElephant.translation.y"];
</code></pre>

<ul>
<li><strong>XY轴平移</strong></li>
</ul>
<pre><code>
CABasicAnimation *translation=[CABasicAnimation animationWithKeyPath:@"transform.translation"];
translation.toValue=[NSValue valueWithCGPoint:CGPointMake(100, 100)];
translation.duration=5;
translation.removedOnCompletion=NO;
translation.fillMode=kCAFillModeForwards;
translation.repeatCount=MAXFLOAT;
translation.autoreverses=YES;
[self.translationImgView.layer addAnimation:translation forKey:@"FlyElephant.translation"];
</code></pre>

<p><font color="blue"><strong>动画实例图：</strong></font></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_14.gif?raw=true" alt="animation"><br></div>

<h4 id="2-CAKeyframeAnimation"><a href="#2-CAKeyframeAnimation" class="headerlink" title="2.CAKeyframeAnimation"></a>2.CAKeyframeAnimation</h4><p>CAKeyframeAnimation我们一般称为关键帧动画，主要是利用其values属性，设置多个关键帧属性值，来产生动画。</p>
<h5 id="基于Scale变换"><a href="#基于Scale变换" class="headerlink" title="基于Scale变换:"></a>基于Scale变换:</h5><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_15.gif?raw=true" alt="animation"><br></div>

<pre><code>
CAKeyframeAnimation *keyAnimation = [CAKeyframeAnimation animationWithKeyPath:@"transform"];
keyAnimation.duration = 1.0f;
keyAnimation.beginTime = CACurrentMediaTime() + 1.0;

CATransform3D transform1 = CATransform3DMakeScale(1.5, 1.5, 0);
CATransform3D transform2 = CATransform3DMakeScale(0.8, 0.8, 0);
CATransform3D transform3 = CATransform3DMakeScale(3, 3, 0);

keyAnimation.values = @[[NSValue valueWithCATransform3D:transform1],[NSValue valueWithCATransform3D:transform2],[NSValue valueWithCATransform3D:transform3]];
keyAnimation.keyTimes = @[@0,@0.5,@1];
keyAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
keyAnimation.removedOnCompletion = NO;
keyAnimation.fillMode = kCAFillModeForwards;
[_someView.layer addAnimation:keyAnimation forKey:nil];
</code></pre>

<blockquote>
<ul>
<li><code>beginTime</code> 也是<code>CAAnimation</code>类的属性，可以设置动画延迟多久执行，示例代码是延迟1秒执行。</li>
<li><code>values</code> 是<code>CAKeyframeAnimation</code>的属性，设置keyPath属性在几个关键帧的值，也是id类型的。</li>
<li><code>keyTimes</code> 也是<code>CAKeyframeAnimation</code>的属性，每个值对应相应关键帧的时间比例值。</li>
<li><code>timingFunctions</code> 也是<code>CAKeyframeAnimation</code>的属性，对应每个动画段的动画过渡情况；而<code>timingFunction</code>是<code>CAAnimation</code>的属性。</li>
</ul>
</blockquote>
<h5 id="基于Point的变换"><a href="#基于Point的变换" class="headerlink" title="基于Point的变换:"></a>基于Point的变换:</h5><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_16.gif?raw=true" alt="animation"><br></div>

<pre><code>
CGPoint p1=CGPointMake(self.positionImgView.center.x, self.positionImgView.center.y);
CGPoint p2=CGPointMake(80, 100);
CGPoint p3=CGPointMake(100, 120);

CGPoint p4=CGPointMake(120, 150);
CGPoint p5=CGPointMake(140, 160);
NSArray *values=[NSArray arrayWithObjects:[NSValue valueWithCGPoint:p1],[NSValue valueWithCGPoint:p2],[NSValue valueWithCGPoint:p3],[NSValue valueWithCGPoint:p4],[NSValue valueWithCGPoint:p5], nil];
CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"position"];
[animation setValues:values];
[animation setDuration:10.0];
[animation setCalculationMode:kCAAnimationCubic];
animation.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];
[self.positionImgView.layer addAnimation:animation forKey:@"FlyElephant.point"];
</code></pre>

<h5 id="基于Path的变换"><a href="#基于Path的变换" class="headerlink" title="基于Path的变换:"></a>基于Path的变换:</h5><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_17.gif?raw=true" alt="animation"><br></div>

<pre><code>
CGMutablePathRef path = CGPathCreateMutable();
CGPathMoveToPoint(path,NULL,self.positionImgView.center.x,self.positionImgView.center.y);
for(NSInteger i = 1; i < 5 i++){
    CGPathAddLineToPoint(path, NULL, self.positionImgView.center.x+i*10,     self.positionImgView.center.y);
}
//曲线
CGPathAddCurveToPoint(path,NULL,50.0,275.0,150.0,275.0,70.0,120.0);
CGPathAddCurveToPoint(path,NULL,150.0,275.0,250.0,275.0,90.0,120.0);
CGPathAddCurveToPoint(path,NULL,250.0,275.0,350.0,275.0,110.0,120.0);
CGPathAddCurveToPoint(path,NULL,350.0,275.0,450.0,275.0,130.0,120.0);
CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"position"];
[animation setPath:path];
[animation setDuration:3.0];
// [animation setAutoreverses:YES];
CFRelease(path);
[self.positionImgView.layer addAnimation:animation:@"FlyElephant"];
</code></pre>

<p>通过代码我们发现，Path和values接收都是一个数组，而不是一个固定值，这里面我们没有设置keyTimes，下面看一个常见的抖动效果:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_18.gif?raw=true" alt="animation"><br></div>

<pre><code>
CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
animation.keyPath = @"position.x";
animation.values = @[ @0, @20, @-20, @20, @0 ];
animation.keyTimes = @[ @0, @(1 /8.0), @(1/ 2.0), @(7/ 8.0), @1 ];
animation.duration =0.5;
animation.additive = YES;
[self.textField.layer addAnimation:animation forKey:@"FlyElephant.Shake"];
</code></pre>

<h4 id="3-CAAnimationGroup"><a href="#3-CAAnimationGroup" class="headerlink" title="3.CAAnimationGroup"></a>3.CAAnimationGroup</h4><p>CAAnimationGroup的用法与其他动画类一样，都是添加到layer上，比CAAnimation多了一个animations属性。<br>先看示例代码，动画效果是视图一边向上移动，一边绕Y轴旋转：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_19.gif?raw=true" alt="animation"><br></div>

<pre><code>
CABasicAnimation *rotationYAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"];
rotationYAnimation.fromValue = @0;
rotationYAnimation.toValue = @(M_PI);
rotationYAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];

CABasicAnimation *postionAnimation = [CABasicAnimation animationWithKeyPath:@"position.y"];
postionAnimation.fromValue = @(_markView.center.y);
postionAnimation.toValue = @(_markView.center.y - 100);
postionAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];

CAAnimationGroup *animationGroup = [CAAnimationGroup animation];
animationGroup.duration = kUpDuration;
animationGroup.removedOnCompletion = NO;
animationGroup.fillMode = kCAFillModeForwards;
animationGroup.delegate = self;
animationGroup.animations = @[rotationYAnimation, postionAnimation];

[_markView.layer addAnimation:animationGroup forKey:kJumpAnimation];
</code></pre>

<blockquote>
<p>CAAnimationGroup的animations中可以放其他任何动画类（包括CAAnimationGroup），需要注意的是animations里的动画设置了duration之后动画可能会有不同，一般里面不设置，在最外层设置group的duration即可。</p>
</blockquote>
<h5 id="AnimationWithKeyPath的值"><a href="#AnimationWithKeyPath的值" class="headerlink" title="AnimationWithKeyPath的值"></a>AnimationWithKeyPath的值</h5><p>最开始做动画一般都会对keyPath这个值莫名其妙，因为它不是常量，需要变换的时候找不到对应的需要设置的值，如果你在网上搜索，很可能看到的是这张图:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_20.png?raw=true" alt="animation"><br></div><br>下面这张图你基本上是找不到的，如下:<br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_21.png?raw=true" alt="animation"><br></div>

<h4 id="4-CATransition"><a href="#4-CATransition" class="headerlink" title="4.CATransition"></a>4.CATransition</h4><p>CATransition一般来做转场动画。先上gif动画效果</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_22.gif?raw=true" alt="animation"><br></div>

<pre><code>
//修改视图的背景色
_someView.backgroundColor = [UIColor greenColor];
CATransition *animation = [CATransition animation];
animation.duration = 0.5;
/* 这里可设置的参数有：kCATransitionFade、kCATransitionPush、kCATransitionReveal、kCATransitionMoveIn、
"cube"、"suckEffect"、"oglFlip"、"rippleEffect"、"pageCurl"、"pageUnCurl"、"cameraIrisHollowOpen"、
 "cameraIrisHollowClose"，这些都是动画类型
*/
animation.type = @"cube";
// 动画执行的方向，kCATransitionFromRight、kCATransitionFromLeft、kCATransitionFromTop、kCATransitionFromBottom
animation.subtype = kCATransitionFromRight;
animation.timingFunction = UIViewAnimationOptionCurveEaseInOut;
[_someView.layer addAnimation:animation forKey:nil];
//也可以写这里
//    _someView.backgroundColor = [UIColor greenColor];
</code></pre>

<p>只需要在动画开始前或者动画开始后替换掉视图上显示的内容即可。具体可以看我的这篇博客<a href="http://www.guiyongdong.com/2016/09/22/iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCATransition%E5%8A%A8%E7%94%BB/" target="_blank" rel="external">iOS动画之CATransition动画</a></p>
<h4 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h4><p>附加的内容是关于CALayer和UIBezierPath。个人觉得理解了UIBezierPath和CALayer,才能更好的理解CoreAnimation动画。</p>
<h5 id="1-UIBezierPath"><a href="#1-UIBezierPath" class="headerlink" title="1.UIBezierPath"></a>1.UIBezierPath</h5><p>UIBezierPath主要是用来绘制路径的，分为一阶、二阶…..n阶。一阶是直线，二阶以上才是曲线。而最终路径的显示还是得依靠CALayer。用CoreGraphics将路径绘制出来，最终也是绘制到CALayer上。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_23.png?raw=true" alt="animation"><br></div>

<blockquote>
<p>方法一：构造bezierPath对象，一般用于自定义路径。<br>方法二：绘制圆弧路径，参数1是中心点位置，参数2是半径，参数3是开始的弧度值，参数4是结束的弧度值，参数5是是否顺时针(YES是顺时针方向，NO逆时针)。<br>方法三：根据某个路径绘制路径。<br>方法四：根据某个CGRect绘制内切圆或椭圆（CGRect是正方形即为圆，为长方形则为椭圆）。<br>方法五：根据某个CGRect绘制路径。<br>方法六：绘制带圆角的矩形路径，参数2哪个角，参数3，横、纵向半径。<br>方法七：绘制每个角都是圆角的矩形，参数2是半径。</p>
</blockquote>
<p>自定义路径时常用的API:</p>
<pre><code>
- (void)moveToPoint:(CGPoint)point; // 移到某个点
- (void)addLineToPoint:(CGPoint)point; // 绘制直线
- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; //绘制贝塞尔曲线
- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; // 绘制规则的贝塞尔曲线
- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise
// 绘制圆形曲线
- (void)appendPath:(UIBezierPath *)bezierPath; // 拼接曲线
</code></pre>

<h5 id="如果将路径显示的图案显示到视图上呢？"><a href="#如果将路径显示的图案显示到视图上呢？" class="headerlink" title="如果将路径显示的图案显示到视图上呢？"></a>如果将路径显示的图案显示到视图上呢？</h5><p>有三种方式：1、直接使用UIBezierPath的方法；2、使用CoreGraphics绘制；3、利用CAShapeLayer绘制。<br>示例代码如下，绘制一个右侧为弧型的视图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_24.gif?raw=true" alt="animation"><br></div>

<pre><code>
- (void)drawRect:(CGRect)rect
{
    UIColor *fillColor = [UIColor colorWithRed:0.0 green:0.722 blue:1.0 alpha:1.0];

    UIBezierPath *bezierPath = [UIBezierPath bezierPath];
    [bezierPath moveToPoint:CGPointMake(0, 0)];
    [bezierPath addLineToPoint:CGPointMake(rect.size.width - spaceWidth, 0)];
    [bezierPath addQuadCurveToPoint:CGPointMake(rect.size.width - spaceWidth, rect.size.height) controlPoint:CGPointMake(rect.size.width - spaceWidth + _deltaWith, rect.size.height * 0.5)];
    [bezierPath addLineToPoint:CGPointMake(0, rect.size.height)];
    [bezierPath addLineToPoint:CGPointMake(0, 0)];
    [bezierPath closePath];

    // 1、bezierPath方法
//    [fillColor setFill];
//    [bezierPath fill];

    // 2、使用CoreGraphics
//    CGContextRef ctx = UIGraphicsGetCurrentContext();
//    CGContextAddPath(ctx, bezierPath.CGPath);
//    CGContextSetFillColorWithColor(ctx, fillColor.CGColor);
//    CGContextFillPath(ctx);

    // 3.CAShaperLayer
    [self.layer.sublayers makeObjectsPerformSelector:@selector(removeFromSuperlayer)];
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.path = bezierPath.CGPath;
    shapeLayer.fillColor = fillColor.CGColor;
    [self.layer addSublayer:shapeLayer];
}
</code></pre>

<p><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_25.gif?raw=true" alt="animation"><br></div><br>上图这样的视图是用UIBezierPath用多个CAShapeLayer制作出来的，而动画效果只需要改变进度的layer的strokeEnd和修改下面代表水面进度的视图位置即可。动画的组合也可以有多种方式组合<br>动画的示例代码：</p>
<pre><code>
- (void)setProgress:(CGFloat)progress animated:(BOOL)animated duration:(NSTimeInterval)duration
{
    CGFloat tempPro = progress;
    if (tempPro > 1.0) {
        tempPro = 1.0;
    } else if (progress < 0.0){
        tempPro = 0.0;
    }
    _progress = tempPro;

    CABasicAnimation *pathAniamtion = [CABasicAnimation animationWithKeyPath:@"strokeEnd"];
    pathAniamtion.duration = duration;
    pathAniamtion.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    pathAniamtion.fromValue = [NSNumber numberWithFloat:0.0f];
    pathAniamtion.toValue = [NSNumber numberWithFloat:_progress];
    pathAniamtion.autoreverses = NO;
    [_progressLayer addAnimation:pathAniamtion forKey:nil];

    // 水位上升的动画
    if (!_showSolidAnimation) {
        return;
    }

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        _imageView.transform = CGAffineTransformIdentity;
        [UIView animateWithDuration:duration animations:^{
            CGRect rect = _imageView.frame;
            CGFloat dy = rect.size.height * progress;
            _imageView.transform = CGAffineTransformMakeTranslation(0, -dy);
        }];
    });
}
</code></pre>

<p>在用自定义的CAShapeLayer做动画时，建议在动画开始前先将动画属性与最终的属性值一致，再开始动画，不要使用removedOnCompletion控制最终的状态，这在WWDC苹果这么建议。</p>
<p><strong>具体UIBezierPath可以看这篇文章<a href="http://www.guiyongdong.com/2016/09/22/UIBezierPath%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">UIBezierPath详解</a></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS动画之CATransition动画]]></title>
      <url>http://yoursite.com/2016/02/08/iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCATransition%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p>今天主要用到的动画类是CALayer下的CATransition至于各种动画类中如何继承的在这也不做赘述，网上的资料是一抓一大把。好废话少说切入今天的正题。</p>
<a id="more"></a>
<h3 id="一-封装动画方法"><a href="#一-封装动画方法" class="headerlink" title="一.封装动画方法"></a>一.封装动画方法</h3><h5 id="1-用CATransition实现动画的封装方法如下，每句代码是何意思，请看注释之。"><a href="#1-用CATransition实现动画的封装方法如下，每句代码是何意思，请看注释之。" class="headerlink" title="1.用CATransition实现动画的封装方法如下，每句代码是何意思，请看注释之。"></a>1.用CATransition实现动画的封装方法如下，每句代码是何意思，请看注释之。</h5><pre><code>
 #pragma CATransition动画实现
 - (void) transitionWithType:(NSString *) type WithSubtype:(NSString *) subtype ForView : (UIView *) view
 {
     //创建CATransition对象
     CATransition *animation = [CATransition animation];

     //设置运动时间
     animation.duration = DURATION;

     //设置运动type
     animation.type = type;
     if (subtype != nil) {

         //设置子类
         animation.subtype = subtype;
     }

     //设置运动速度
     animation.timingFunction = UIViewAnimationOptionCurveEaseInOut;

     [view.layer addAnimation:animation forKey:@"animation"];
 }
</code></pre>

<p><strong>代码说明：</strong><br><strong>CATransition</strong>常用的属性如下：</p>
<ul>
<li><strong>duration</strong>:设置动画时间</li>
<li><strong>type</strong>:稍后下面会详细的介绍运动类型</li>
<li><strong>subtype</strong>:和type匹配使用，指定运动的方向，下面也会详细介绍</li>
<li><strong>timingFunction</strong> ：<ul>
<li>动画的运动轨迹，用于变化起点和终点之间的插值计算,形象点说它决定了动画运行的节奏,比如是均匀变化(相同时间变化量相同)还是先快后慢,先慢后快还是先慢再快再慢.</li>
<li>动画的开始与结束的快慢,有五个预置分别为(下同):<ul>
<li>kCAMediaTimingFunctionLinear            线性,即匀速</li>
<li>kCAMediaTimingFunctionEaseIn            先慢后快</li>
<li>kCAMediaTimingFunctionEaseOut           先快后慢</li>
<li>kCAMediaTimingFunctionEaseInEaseOut     先慢后快再慢</li>
<li>kCAMediaTimingFunctionDefault           实际效果是动画中间比较快.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-用UIView的block回调实现动画的代码封装"><a href="#2-用UIView的block回调实现动画的代码封装" class="headerlink" title="2.用UIView的block回调实现动画的代码封装　"></a>2.用UIView的block回调实现动画的代码封装　</h5><pre><code>
 #pragma UIView实现动画
 - (void) animationWithView : (UIView *)view WithAnimationTransition : (UIViewAnimationTransition) transition
 {
     [UIView animateWithDuration:DURATION animations:^{
         [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
         [UIView setAnimationTransition:transition forView:view cache:YES];
     }];
 }
</code></pre>

<h5 id="3-改变View的背景图，便于切换时观察"><a href="#3-改变View的背景图，便于切换时观察" class="headerlink" title="3.改变View的背景图，便于切换时观察"></a>3.改变View的背景图，便于切换时观察</h5><pre><code>
 #pragma 给View添加背景图
 -(void)addBgImageWithImageName:(NSString *) imageName
 {
     self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:imageName]];
 }
</code></pre>

<h3 id="二-调用上面的方法实现我们想要的动画"><a href="#二-调用上面的方法实现我们想要的动画" class="headerlink" title="二.调用上面的方法实现我们想要的动画"></a>二.调用上面的方法实现我们想要的动画</h3><h5 id="1-我们在View上添加多个Button-给不同的Button设置不同的Tag值，然后再ViewController中绑定同一个方法，点击不同的button实现不同的页面切换效果。storyBoard上的控件效果如下图所示："><a href="#1-我们在View上添加多个Button-给不同的Button设置不同的Tag值，然后再ViewController中绑定同一个方法，点击不同的button实现不同的页面切换效果。storyBoard上的控件效果如下图所示：" class="headerlink" title="1.我们在View上添加多个Button,给不同的Button设置不同的Tag值，然后再ViewController中绑定同一个方法，点击不同的button实现不同的页面切换效果。storyBoard上的控件效果如下图所示："></a>1.我们在View上添加多个Button,给不同的Button设置不同的Tag值，然后再ViewController中绑定同一个方法，点击不同的button实现不同的页面切换效果。storyBoard上的控件效果如下图所示：</h5><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_1.png?raw=true" alt="image" width="375" height="667/"><br></div>

<h5 id="2-下面我们就开始编写点击button要回调的方法"><a href="#2-下面我们就开始编写点击button要回调的方法" class="headerlink" title="2.下面我们就开始编写点击button要回调的方法"></a>2.下面我们就开始编写点击button要回调的方法</h5><ul>
<li>定义枚举来标示按钮所对应的动画类型，代码如下：</li>
</ul>
<pre><code>
typedef enum : NSUInteger {
    Fade = 1,                   //淡入淡出
    Push,                       //推挤
    Reveal,                     //揭开
    MoveIn,                     //覆盖
    Cube,                       //立方体
    SuckEffect,                 //吮吸
    OglFlip,                    //翻转
    RippleEffect,               //波纹
    PageCurl,                   //翻页
    PageUnCurl,                 //反翻页
    CameraIrisHollowOpen,       //开镜头
    CameraIrisHollowClose,      //关镜头
    CurlDown,                   //下翻页
    CurlUp,                     //上翻页
    FlipFromLeft,               //左翻转
    FlipFromRight,              //右翻转

} AnimationType;
</code></pre>

<ul>
<li>获取Button的Tag值：</li>
</ul>
<pre><code>
     UIButton *button = sender;
     AnimationType animationType = button.tag;
</code></pre>

<ul>
<li>每次点击button都改变subtype的值，包括上,左,下,右</li>
</ul>
<pre><code>
NSString *subtypeString;

    switch (_subtype) {
        case 0:
            subtypeString = kCATransitionFromLeft;
            break;
        case 1:
            subtypeString = kCATransitionFromBottom;
            break;
        case 2:
            subtypeString = kCATransitionFromRight;
            break;
        case 3:
            subtypeString = kCATransitionFromTop;
            break;
        default:
            break;
    }
    _subtype += 1;
    if (_subtype > 3) {
        _subtype = 0;
    }
</code></pre>

<ul>
<li>通过switch结合上边的枚举来判断是那个按钮点击的</li>
</ul>
<pre><code>
 switch (animationType)
 {
     //各种Case,此处代码下面会给出  
 }
</code></pre>

<h5 id="3-调用我们封装的运动方法，来实现动画效果"><a href="#3-调用我们封装的运动方法，来实现动画效果" class="headerlink" title="3.调用我们封装的运动方法，来实现动画效果"></a>3.调用我们封装的运动方法，来实现动画效果</h5><ul>
<li>淡化效果</li>
</ul>
<pre><code>
case Fade:
     [self transitionWithType:kCATransitionFade WithSubtype:subtypeString ForView:self.view];
     break;
</code></pre>

<ul>
<li>Push效果</li>
</ul>
<pre><code>
case Push: 
     [self transitionWithType:kCATransitionPush WithSubtype:subtypeString ForView:self.view];
     break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_2.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>揭开效果：</li>
</ul>
<pre><code>
case Reveal:
    [self transitionWithType:kCATransitionReveal WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_3.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>覆盖效果：</li>
</ul>
<pre><code>
case MoveIn:
    [self transitionWithType:kCATransitionMoveIn WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_4.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>立方体效果：</li>
</ul>
<pre><code>
case Cube:
    [self transitionWithType:@"cube" WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_5.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>吮吸效果：</li>
</ul>
<pre><code>
case SuckEffect:
    [self transitionWithType:@"suckEffect" WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_6.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>翻转效果：</li>
</ul>
<pre><code>
case OglFlip:
    [self transitionWithType:@"oglFlip" WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_7.png?raw=true" alt="image" width="375" height="667"><br></div> 

<ul>
<li>波纹效果：</li>
</ul>
<pre><code>
case RippleEffect:
    [self transitionWithType:@"rippleEffect" WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_8.png?raw=true" alt="image" width="375" height="667"><br></div> 

<ul>
<li>翻页和反翻页效果：</li>
</ul>
<pre><code>
case PageCurl:
            [self transitionWithType:@"pageCurl" WithSubtype:subtypeString ForView:self.view];
            break;

        case PageUnCurl:
            [self transitionWithType:@"pageUnCurl" WithSubtype:subtypeString ForView:self.view];
            break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_9.png?raw=true" alt="image" width="375" height="667"><br></div><br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_10.png?raw=true" alt="image" width="375" height="667"><br></div> 

<ul>
<li>相机打开效果：</li>
</ul>
<pre><code>
case CameraIrisHollowOpen:
            [self transitionWithType:@"cameraIrisHollowOpen" WithSubtype:subtypeString ForView:self.view];
            break;

        case CameraIrisHollowClose:
            [self transitionWithType:@"cameraIrisHollowClose" WithSubtype:subtypeString ForView:self.view];
            break;
</code></pre>

<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_11.png?raw=true" alt="image" width="375" height="667"><br></div> 

<ul>
<li>调用上面封装的第二个动画方法</li>
</ul>
<pre><code>
case CurlDown:
            [self animationWithView:self.view WithAnimationTransition:UIViewAnimationTransitionCurlDown];
            break;

        case CurlUp:
            [self animationWithView:self.view WithAnimationTransition:UIViewAnimationTransitionCurlUp];
            break;

        case FlipFromLeft:
            [self animationWithView:self.view WithAnimationTransition:UIViewAnimationTransitionFlipFromLeft];
            break;

        case FlipFromRight:
            [self animationWithView:self.view WithAnimationTransition:UIViewAnimationTransitionFlipFromRight];
            break;
</code></pre>

<p><a href="https://github.com/guiyongdong/Resource/tree/master/demo/CATransitionDemo" target="_blank" rel="external">Demo传送门</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RunLoop总结]]></title>
      <url>http://yoursite.com/2016/02/01/RunLoop%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近研究了一下RunLoop，在这里对RunLoop做一个总结，主要是对<code>&lt;CoreFoundation/CFRunLoop.h&gt;</code>的头文件函数总结。</p>
<a id="more"></a>
<h3 id="关于RunLoop的资料总结"><a href="#关于RunLoop的资料总结" class="headerlink" title="关于RunLoop的资料总结"></a>关于RunLoop的资料总结</h3><p>网上关于RunLoop的总结大致相同，这里推荐几篇好的文章共大家学习。</p>
<ul>
<li><p>YYModel作者关于RunLoop的总结 《<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>》</p>
</li>
<li><p>简书上不错的文章 《<a href="http://www.jianshu.com/p/37ab0397fec7" target="_blank" rel="external">【iOS程序启动与运转】- RunLoop个人小结</a>》</p>
</li>
<li><p>sunnyxx的RunLoop线下讨论会 <a href="https://pan.baidu.com/s/1i5bN3dN" target="_blank" rel="external">百度网盘</a></p>
</li>
<li><p>用RunLoop捕获程序Crash 防止用户使用时程序崩溃 <a href="https://github.com/guiyongdong/Resource/tree/master/%20CrashManager" target="_blank" rel="external">git连接</a></p>
</li>
</ul>
<h3 id="关于CFRunLoop-h的总结"><a href="#关于CFRunLoop-h的总结" class="headerlink" title="关于CFRunLoop.h的总结"></a>关于CFRunLoop.h的总结</h3><pre><code>

//Runloop
typedef struct __CFRunLoop * CFRunLoopRef;
//事件源
typedef struct __CFRunLoopSource * CFRunLoopSourceRef;
//观察者
typedef struct __CFRunLoopObserver * CFRunLoopObserverRef;
//定时器
typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;

/* Reasons for CFRunLoopRunInMode() to Return */
enum {
    kCFRunLoopRunFinished = 1, //Run Loop结束，没有Timer或者其他Input Source
    kCFRunLoopRunStopped = 2, //Run Loop被停止，使用CFRunLoopStop停止Run Loop
    kCFRunLoopRunTimedOut = 3, //RunLoop 超时
    kCFRunLoopRunHandledSource = 4 //Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行
};

/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL << 0), // 即将进入Loop
    kCFRunLoopBeforeTimers = (1UL << 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
    kCFRunLoopAfterWaiting = (1UL << 6), // 刚从休眠中唤醒
    kCFRunLoopExit = (1UL << 7), // 即将退出Loop
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};

//默认model
CF_EXPORT const CFStringRef kCFRunLoopDefaultMode;
//当uiscrollView滑动时Model
CF_EXPORT const CFStringRef kCFRunLoopCommonModes;

//获取当前RunLoop 当当前RunLoop没有的时候回创建一个  一个线程对应一个RunLoop
CF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);
//获取主线程的RunLoop
CF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);
//复制当前RunLoop
CF_EXPORT CFStringRef CFRunLoopCopyCurrentMode(CFRunLoopRef rl);
//复制当前RunLoop的所有Model
CF_EXPORT CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl);
//给当前RunLoop添加Model
CF_EXPORT void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef mode);
//获取RunLoop model的超时时间
CF_EXPORT CFAbsoluteTime CFRunLoopGetNextTimerFireDate(CFRunLoopRef rl, CFStringRef mode);
//手动启动RunLoop
CF_EXPORT void CFRunLoopRun(void);
/**
 *  切换当前RunLoop的model
 *
 *  @param mode                     model
 *  @param seconds                  执行时间
 *  @param returnAfterSourceHandled 执行完是否结束
 */
CF_EXPORT SInt32 CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled);
//当前RunLoop是否休眠
CF_EXPORT Boolean CFRunLoopIsWaiting(CFRunLoopRef rl);
//唤醒RunLoop
CF_EXPORT void CFRunLoopWakeUp(CFRunLoopRef rl);
//手动停止RunLoop
CF_EXPORT void CFRunLoopStop(CFRunLoopRef rl);

#if __BLOCKS__
//在RunLoop 特定Model执行 操作
CF_EXPORT void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) CF_AVAILABLE(10_6, 4_0); 
#endif
//RunLoop下是否包含某个Source
CF_EXPORT Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);
//添加Source
CF_EXPORT void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);
//移除Source
CF_EXPORT void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);
//是否包换观察者
CF_EXPORT Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);
//添加某个model下的观察者
CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);
//移除观察者
CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);
//是否包含定时器
CF_EXPORT Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
//添加定时器
CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
//移除定时器
CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);

typedef struct {
    CFIndex    version;
    void *    info;
    const void *(*retain)(const void *info);
    void    (*release)(const void *info);
    CFStringRef    (*copyDescription)(const void *info);
    Boolean    (*equal)(const void *info1, const void *info2);
    CFHashCode    (*hash)(const void *info);
    void    (*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode);
    void    (*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode);
    void    (*perform)(void *info);
} CFRunLoopSourceContext;

typedef struct {
    CFIndex    version;
    void *    info;
    const void *(*retain)(const void *info);
    void    (*release)(const void *info);
    CFStringRef    (*copyDescription)(const void *info);
    Boolean    (*equal)(const void *info1, const void *info2);
    CFHashCode    (*hash)(const void *info);
#if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)
    mach_port_t    (*getPort)(void *info);
    void *    (*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);
#else
    void *    (*getPort)(void *info);
    void    (*perform)(void *info);
#endif
} CFRunLoopSourceContext1;

CF_EXPORT CFTypeID CFRunLoopSourceGetTypeID(void);

//创建事件源
CF_EXPORT CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context);

CF_EXPORT CFIndex CFRunLoopSourceGetOrder(CFRunLoopSourceRef source);
CF_EXPORT void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source);
CF_EXPORT Boolean CFRunLoopSourceIsValid(CFRunLoopSourceRef source);
CF_EXPORT void CFRunLoopSourceGetContext(CFRunLoopSourceRef source, CFRunLoopSourceContext *context);
CF_EXPORT void CFRunLoopSourceSignal(CFRunLoopSourceRef source);

typedef struct {
    CFIndex    version;
    void *    info;
    const void *(*retain)(const void *info);
    void    (*release)(const void *info);
    CFStringRef    (*copyDescription)(const void *info);
} CFRunLoopObserverContext;

typedef void (*CFRunLoopObserverCallBack)(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);

CF_EXPORT CFTypeID CFRunLoopObserverGetTypeID(void);

CF_EXPORT CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context);
#if __BLOCKS__
/**
 *  创建观察者
 *
 *  @param allocator  默认 kCFAllocatorDefault
 *  @param activities 监听 RunLoop的哪种状态
 *  @param repeats    是否一直监听
 *  @param order      优先级 默认 0
 *  @param ^block     回调
 *
 */
CF_EXPORT CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void (^block) (CFRunLoopObserverRef observer, CFRunLoopActivity activity)) CF_AVAILABLE(10_7, 5_0);
#endif

//获取当前观察者观察的状态
CF_EXPORT CFOptionFlags CFRunLoopObserverGetActivities(CFRunLoopObserverRef observer);
//获取当前观察者是否一直观察
CF_EXPORT Boolean CFRunLoopObserverDoesRepeat(CFRunLoopObserverRef observer);
//获取优先级
CF_EXPORT CFIndex CFRunLoopObserverGetOrder(CFRunLoopObserverRef observer);
CF_EXPORT void CFRunLoopObserverInvalidate(CFRunLoopObserverRef observer);
CF_EXPORT Boolean CFRunLoopObserverIsValid(CFRunLoopObserverRef observer);
CF_EXPORT void CFRunLoopObserverGetContext(CFRunLoopObserverRef observer, CFRunLoopObserverContext *context);

typedef struct {
    CFIndex    version;
    void *    info;
    const void *(*retain)(const void *info);
    void    (*release)(const void *info);
    CFStringRef    (*copyDescription)(const void *info);
} CFRunLoopTimerContext;

typedef void (*CFRunLoopTimerCallBack)(CFRunLoopTimerRef timer, void *info);

CF_EXPORT CFTypeID CFRunLoopTimerGetTypeID(void);
//创建定时器
CF_EXPORT CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context);
#if __BLOCKS__
//使用Block创建定时器
CF_EXPORT CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void (^block) (CFRunLoopTimerRef timer)) CF_AVAILABLE(10_7, 5_0);
#endif
//获取超时时间
CF_EXPORT CFAbsoluteTime CFRunLoopTimerGetNextFireDate(CFRunLoopTimerRef timer);
//设置超时时间
CF_EXPORT void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate);
CF_EXPORT CFTimeInterval CFRunLoopTimerGetInterval(CFRunLoopTimerRef timer);
//是否循环执行
CF_EXPORT Boolean CFRunLoopTimerDoesRepeat(CFRunLoopTimerRef timer);
//获取优先级
CF_EXPORT CFIndex CFRunLoopTimerGetOrder(CFRunLoopTimerRef timer);
CF_EXPORT void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer);
CF_EXPORT Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer);
CF_EXPORT void CFRunLoopTimerGetContext(CFRunLoopTimerRef timer, CFRunLoopTimerContext *context);

// Setting a tolerance for a timer allows it to fire later than the scheduled fire date, improving the ability of the system to optimize for increased power savings and responsiveness. The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift. The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of this property.
// As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.
CF_EXPORT CFTimeInterval CFRunLoopTimerGetTolerance(CFRunLoopTimerRef timer) CF_AVAILABLE(10_9, 7_0);
CF_EXPORT void CFRunLoopTimerSetTolerance(CFRunLoopTimerRef timer, CFTimeInterval tolerance) CF_AVAILABLE(10_9, 7_0);

CF_EXTERN_C_END
CF_IMPLICIT_BRIDGING_DISABLED


</code></pre>






<!-- more -->
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ReactiveCocoa和RXSwift速查表]]></title>
      <url>http://yoursite.com/2016/01/24/ReactiveCocoa%E5%92%8CRXSwift%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>在接触了RAC以后,对RAC有了一个基本的了解，这里整理了一下RAC脑图，方便日后查看。ps(<a href="https://github.com/aiqiuqiu/FRPCheatSheeta" target="_blank" rel="external">转载</a>)</p>
<a id="more"></a>
<h3 id="ReactiveCocoa-Objective-C部分"><a href="#ReactiveCocoa-Objective-C部分" class="headerlink" title="ReactiveCocoa-Objective-C部分"></a>ReactiveCocoa-Objective-C部分</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/ReactiveCocoa-Objective-C.png?raw=true" alt="ReactiveCocoa-Objective-C Swartz"></p>
<h3 id="ReactiveCocoaV4-x-Swift部分"><a href="#ReactiveCocoaV4-x-Swift部分" class="headerlink" title="ReactiveCocoaV4.x-Swift部分"></a>ReactiveCocoaV4.x-Swift部分</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/ReactiveCocoaV4.x-Swift.png?raw=true" alt="ReactiveCocoaV4.x-Swift Swartz"></p>
<h3 id="RXSwift部分"><a href="#RXSwift部分" class="headerlink" title="RXSwift部分"></a>RXSwift部分</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/RXSwift.png?raw=true" alt="ReactiveCocoaV4.x-Swift Swartz"></p>
<!-- more -->
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIBezierPath详解]]></title>
      <url>http://yoursite.com/2016/01/22/UIBezierPath%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>我在写本篇文章之前，也没有系统学习过贝塞尔曲线，只是曾经某一次的需求需要使用到，才临时百度看了一看而且使用最基本的功能。现在总算有时间停下来好好研究研究这个神奇而伟大的贝塞尔先生！</p>
<a id="more"></a>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><hr>
<p>使用<code>UIBezierPath</code>可以创建基于矢量的路径，此类是<code>Core Graphics</code>框架关于路径的封装。使用此类可以定义简单的形状，如椭圆、矩形或者有多个直线和曲线段组成的形状等。</p>
<p><code>UIBezierPath</code>是<code>CGPathRef</code>数据类型的封装。如果是基于矢量形状的路径，都用直线和曲线去创建。我们使用直线段去创建矩形和多边形，使用曲线去创建圆弧（arc）、圆或者其他复杂的曲线形状。</p>
<p>使用<code>UIBezierPath</code>画图步骤：</p>
<ol>
<li>创建一个UIBezierPath对象</li>
<li>调用-moveToPoint:设置初始线段的起点</li>
<li>添加线或者曲线去定义一个或者多个子路径</li>
<li>改变UIBezierPath对象跟绘图相关的属性。如，我们可以设置画笔的属性、填充样式等</li>
</ol>
<h4 id="UIBezierPath创建方法介绍"><a href="#UIBezierPath创建方法介绍" class="headerlink" title="UIBezierPath创建方法介绍"></a>UIBezierPath创建方法介绍</h4><hr>
<p>我们先看看<code>UIBezierPath</code>类提供了哪些创建方式，这些都是工厂方法，直接使用即可。</p>
<pre><code>
+ (instancetype)bezierPath;
+ (instancetype)bezierPathWithRect:(CGRect)rect;
+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                            cornerRadius:(CGFloat)cornerRadius;
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                        byRoundingCorners:(UIRectCorner)corners 
                              cornerRadii:(CGSize)cornerRadii;
+ (instancetype)bezierPathWithArcCenter:(CGPoint)center 
                                 radius:(CGFloat)radius 
                             startAngle:(CGFloat)startAngle 
                               endAngle:(CGFloat)endAngle 
                              clockwise:(BOOL)clockwise;
+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;
</code></pre>

<p>下面我们一个一个地介绍其用途。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPath;</div></pre></td></tr></table></figure>
<p>这个使用比较多，因为这个工厂方法创建的对象，我们可以根据我们的需要任意定制样式，可以画任何我们想画的图形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithRect:(CGRect)rect;</div></pre></td></tr></table></figure>
<p>这个工厂方法根据一个矩形画贝塞尔曲线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;</div></pre></td></tr></table></figure>
<p>这个工厂方法根据一个矩形画内切曲线。通常用它来画圆或者椭圆。</p>
<pre><code>
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                            cornerRadius:(CGFloat)cornerRadius;
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                        byRoundingCorners:(UIRectCorner)corners 
                              cornerRadii:(CGSize)cornerRadii;
</code></pre>

<p>第一个工厂方法是画矩形，但是这个矩形是可以画圆角的。第一个参数是矩形，第二个参数是圆角大小。<br>第二个工厂方法功能是一样的，但是可以指定某一个角画成圆角。像这种我们就可以很容易地给UIView扩展添加圆角的方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithArcCenter:(CGPoint)center </div><div class="line">                                 radius:(CGFloat)radius </div><div class="line">                             startAngle:(CGFloat)startAngle </div><div class="line">                               endAngle:(CGFloat)endAngle </div><div class="line">                              clockwise:(BOOL)clockwise;</div></pre></td></tr></table></figure>
<p>这个工厂方法用于画弧，参数说明如下：<br><code>center</code>: 弧线中心点的坐标<br><code>radius</code>: 弧线所在圆的半径<br><code>startAngle</code>: 弧线开始的角度值<br><code>endAngle</code>: 弧线结束的角度值<br><code>clockwise</code>: 是否顺时针画弧线</p>
<blockquote>
<p>温馨提示：我们下面的代码都是在自定义的BezierPathView类中的<code>- (void)drawRect:(CGRect)rect</code>方法中调用</p>
</blockquote>
<h5 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h5><hr>
<p>先看效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_1.jpg?raw=true" alt="image"><br></div>

<pre><code>
// 画三角形
- (void)drawTrianglePath {

  UIBezierPath *path = [UIBezierPath bezierPath];
  [path moveToPoint:CGPointMake(20, 20)];
  [path addLineToPoint:CGPointMake(self.frame.size.width - 40, 20)];
  [path addLineToPoint:CGPointMake(self.frame.size.width / 2, self.frame.size.height - 20)];

  // 最后的闭合线是可以通过调用closePath方法来自动生成的，也可以调用-addLineToPoint:方法来添加
  //  [path addLineToPoint:CGPointMake(20, 20)];

  [path closePath];

  // 设置线宽
  path.lineWidth = 1.5;

  // 设置填充颜色
  UIColor *fillColor = [UIColor greenColor];
  [fillColor set];
  [path fill];

  // 设置画笔颜色
  UIColor *strokeColor = [UIColor blueColor];
  [strokeColor set];

  // 根据我们设置的各个点连线
  [path stroke];
}
</code></pre>

<p>我们设置画笔颜色通过set方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIColor *strokeColor = [UIColor blueColor];</div><div class="line">[strokeColor set];</div></pre></td></tr></table></figure></p>
<p>如果我们需要设置填充颜色，比如这里设置为绿色，那么我们需要在设置画笔颜色之前先设置填充颜色，否则画笔颜色就被填充颜色替代了。也就是说，如果要让填充颜色与画笔颜色不一样，那么我们的顺序必须是先设置填充颜色再设置画笔颜色。如下，这两者顺序不能改变。因为我们设置填充颜色也是跟设置画笔颜色一样调用UIColor的-set方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 设置填充颜色</div><div class="line">UIColor *fillColor = [UIColor greenColor];</div><div class="line">[fillColor set];</div><div class="line">[path fill];</div><div class="line"></div><div class="line">// 设置画笔颜色</div><div class="line">UIColor *strokeColor = [UIColor blueColor];</div><div class="line">[strokeColor set];</div></pre></td></tr></table></figure>
<h5 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h5><hr>
<p>先看效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_2.jpg?raw=true" alt="image"><br></div>

<pre><code>
// 画矩形
- (void)drawRectPath {
  UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(20, 20, self.frame.size.width - 40, self.frame.size.height - 40)];

  path.lineWidth = 1.5;
  path.lineCapStyle = kCGLineCapRound;
  path.lineJoinStyle = kCGLineJoinBevel;

  // 设置填充颜色
  UIColor *fillColor = [UIColor greenColor];
  [fillColor set];
  [path fill];

  // 设置画笔颜色
  UIColor *strokeColor = [UIColor blueColor];
  [strokeColor set];

  // 根据我们设置的各个点连线
  [path stroke];
}
</code></pre>

<p>lineCapStyle属性是用来设置线条拐角帽的样式的，其中有三个选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Line cap styles. */</div><div class="line"></div><div class="line">typedef CF_ENUM(int32_t, CGLineCap) &#123;</div><div class="line">    kCGLineCapButt,</div><div class="line">    kCGLineCapRound,</div><div class="line">    kCGLineCapSquare</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，第一个是默认的，第二个是轻微圆角，第三个正方形。</p>
<p>lineJoinStyle属性是用来设置两条线连结点的样式，其中也有三个选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Line join styles. */</div><div class="line"></div><div class="line">typedef CF_ENUM(int32_t, CGLineJoin) &#123;</div><div class="line">    kCGLineJoinMiter,</div><div class="line">    kCGLineJoinRound,</div><div class="line">    kCGLineJoinBevel</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，第一个是默认的表示斜接，第二个是圆滑衔接，第三个是斜角连接。</p>
<h5 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h5><hr>
<p>我们可以使用+ bezierPathWithOvalInRect:方法来画圆，当我们传的rect参数是一下正方形时，画出来的就是圆。</p>
<p>先看效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_3.jpg?raw=true" alt="image"><br></div>

<pre><code>
- (void)drawCiclePath {
  // 传的是正方形，因此就可以绘制出圆了
  UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(20, 20, self.frame.size.width - 40, self.frame.size.width - 40)];

  // 设置填充颜色
  UIColor *fillColor = [UIColor greenColor];
  [fillColor set];
  [path fill];

  // 设置画笔颜色
  UIColor *strokeColor = [UIColor blueColor];
  [strokeColor set];

  // 根据我们设置的各个点连线
  [path stroke];
}
</code></pre>

<blockquote>
<p>注意：要画圆，我们需要传的rect参数必须是正方形哦！</p>
</blockquote>
<h5 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h5><hr>
<p>先看效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_4.jpg?raw=true" alt="image"><br></div><br>前面我们已经画圆了，我们可以使用+ bezierPathWithOvalInRect:方法来画圆，当我们传的rect参数是一下正方形时，画出来的就是圆。那么我们要是不传正方形，那么绘制出来的就是椭圆了。<br><br><pre><code><br>// 画椭圆<br>- (void)drawOvalPath {<br>  // 传的是不是正方形，因此就可以绘制出椭圆圆了<br>  UIBezierPath <em>path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(20, 20, self.frame.size.width - 80, self.frame.size.height - 40)];<br><br>  // 设置填充颜色<br>  UIColor </em>fillColor = [UIColor greenColor];<br>  [fillColor set];<br>  [path fill];<br><br>  // 设置画笔颜色<br>  UIColor <em>strokeColor = [UIColor blueColor];<br>  [strokeColor set];<br><br>  // 根据我们设置的各个点连线<br>  [path stroke];<br>}<br></em></code></pre><br><br>##### 画带圆角的矩形<br>**<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect</div><div class="line">                            cornerRadius:(CGFloat)cornerRadius;</div><div class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect</div><div class="line">                        byRoundingCorners:(UIRectCorner)corners </div><div class="line">                              cornerRadii:(CGSize)cornerRadii;</div></pre></td></tr></table></figure><br><br>第一个工厂方法是画矩形，但是这个矩形是可以画圆角的。第一个参数是矩形，第二个参数是圆角大小。<br>第二个工厂方法功能是一样的，但是可以指定某一个角画成圆角。像这种我们就可以很容易地给UIView扩展添加圆角的方法了。<br><br>四个都是圆角10：<br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_5.jpg?raw=true" alt="image"><br></div>

<pre><code>
- (void)drawRoundedRectPath {
  UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, self.frame.size.width - 40, self.frame.size.height - 40) cornerRadius:10];

  // 设置填充颜色
  UIColor *fillColor = [UIColor greenColor];
  [fillColor set];
  [path fill];

  // 设置画笔颜色
  UIColor *strokeColor = [UIColor blueColor];
  [strokeColor set];

  // 根据我们设置的各个点连线
  [path stroke];
}
</code></pre>

<p>如果要画只有一个角是圆角，那么我们就修改创建方法：</p>
<pre><code>
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, self.frame.size.width - 40, self.frame.size.height - 40) byRoundingCorners:UIRectCornerTopRight cornerRadii:CGSizeMake(20, 20)];
</code></pre>

<p>其中第一个参数一样是传了个矩形，第二个参数是指定在哪个方向画圆角，第三个参数是一个CGSize类型，用来指定水平和垂直方向的半径的大小。看下效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_6.jpg?raw=true" alt="image"><br></div>

<h5 id="画弧"><a href="#画弧" class="headerlink" title="画弧"></a>画弧</h5><hr>
<p>画弧前，我们需要了解其参考系，如下图（图片来自网络）：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_7.jpg?raw=true" alt="image"><br></div>

<pre><code>
#define   kDegreesToRadians(degrees)  ((pi * degrees)/ 180)
- (void)drawARCPath {
  const CGFloat pi = 3.14159265359;

  CGPoint center = CGPointMake(self.frame.size.width / 2, self.frame.size.height / 2);
  UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center
                                                      radius:100
                                                  startAngle:0
                                                    endAngle:kDegreesToRadians(135)
                                                   clockwise:YES];

  path.lineCapStyle = kCGLineCapRound;
  path.lineJoinStyle = kCGLineJoinRound;
  path.lineWidth = 5.0;

  UIColor *strokeColor = [UIColor redColor];
  [strokeColor set];

  [path stroke];
}
</code></pre>

<p>效果图如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_8.jpg?raw=true" alt="image"><br></div>

<p>我们要明确一点，画弧参数startAngle和endAngle使用的是弧度，而不是角度，因此我们需要将常用的角度转换成弧度。对于效果图中，我们设置弧的中心为控件的中心，起点弧度为0，也就是正东方向，而终点是135度角的位置。如果设置的clockwise:YES是逆时针方向绘制，如果设置为NO，效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_9.jpg?raw=true" alt="image"><br></div>

<p>这两者正好是相反的。</p>
<h5 id="画二次贝塞尔曲线"><a href="#画二次贝塞尔曲线" class="headerlink" title="画二次贝塞尔曲线"></a>画二次贝塞尔曲线</h5><hr>
<p>先来学习一下关于控制点，如下图（图片来自网络）：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_10.jpeg?raw=true" alt="image"><br></div><br>画二次贝塞尔曲线，是通过调用此方法来实现的：<br><br><pre><code>- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint<br></code></pre><br><br>参数说明：<br><br>endPoint：终端点<br><br>controlPoint：控制点，对于二次贝塞尔曲线，只有一个控制点<br><br>看效果图：<br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_11.jpg?raw=true" alt="image"><br></div>

<pre><code>
- (void)drawSecondBezierPath {
  UIBezierPath *path = [UIBezierPath bezierPath];

  // 首先设置一个起始点
  [path moveToPoint:CGPointMake(20, self.frame.size.height - 100)];

  // 添加二次曲线
  [path addQuadCurveToPoint:CGPointMake(self.frame.size.width - 20, self.frame.size.height - 100)
               controlPoint:CGPointMake(self.frame.size.width / 2, 0)];

  path.lineCapStyle = kCGLineCapRound;
  path.lineJoinStyle = kCGLineJoinRound;
  path.lineWidth = 5.0;

  UIColor *strokeColor = [UIColor redColor];
  [strokeColor set];

  [path stroke];
}
</code></pre>

<p>画二次贝塞尔曲线的步骤：</p>
<ol>
<li>先设置一个起始点，也就是通过-moveToPoint:设置</li>
<li>调用-addQuadCurveToPoint:controlPoint:方法设置终端点和控制点，以画二次曲线</li>
</ol>
<p>在效果图中，拱桥左边的起始点就是我们设置的起始点，最右边的终点，就是我们设置的终端点，而我们设置的控制点为（width / 2, 0）对应于红色矩形中水平方向在正中央，而垂直方向在最顶部。</p>
<blockquote>
<p>这个样式看起来很像sin或者cos函数吧？这两个只是特例而已，其实可以画任意图形，只是想不到，没有做不到的。</p>
</blockquote>
<h5 id="画三次贝塞尔曲线"><a href="#画三次贝塞尔曲线" class="headerlink" title="画三次贝塞尔曲线"></a>画三次贝塞尔曲线</h5><hr>
<p>贝塞尔曲线必定通过首尾两个点，称为端点；中间两个点虽然未必要通过，但却起到牵制曲线形状路径的作用，称作控制点。关于三次贝塞尔曲线的控制器，看下图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_12.jpeg?raw=true" alt="image"><br></div>

<blockquote>
<p>提示：其组成是起始端点+控制点1+控制点2+终止端点</p>
</blockquote>
<p>如下方法就是画三次贝塞尔曲线的关键方法，以三个点画一段曲线，一般和-moveToPoint:配合使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)addCurveToPoint:(CGPoint)endPoint </div><div class="line">          controlPoint1:(CGPoint)controlPoint1 </div><div class="line">          controlPoint2:(CGPoint)controlPoint2</div></pre></td></tr></table></figure>
<p>看下效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_13.jpg?raw=true" alt="image"><br></div>

<p>实现代码是这样的：</p>
<pre><code>
- (void)drawThirdBezierPath {
  UIBezierPath *path = [UIBezierPath bezierPath];

  // 设置起始端点
  [path moveToPoint:CGPointMake(20, 150)];

  [path addCurveToPoint:CGPointMake(300, 150)
          controlPoint1:CGPointMake(160, 0)
          controlPoint2:CGPointMake(160, 250)];

  path.lineCapStyle = kCGLineCapRound;
  path.lineJoinStyle = kCGLineJoinRound;
  path.lineWidth = 5.0;

  UIColor *strokeColor = [UIColor redColor];
  [strokeColor set];

  [path stroke];
}
</code></pre>

<p>我们需要注意，这里确定的起始端点为(20,150)，终止端点为(300, 150)，基水平方向是一致的。控制点1的坐标是（160，0），水平方向相当于在中间附近，这个参数可以调整。控制点2的坐标是（160，250），如果以两个端点的连线为水平线，那么就是250-150=100，也就是在水平线下100。这样看起来就像一个sin函数了。</p>
]]></content>
    </entry>
    
  
  
</search>
