<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[runtime之NSMutableDictionary安全]]></title>
      <url>http://yoursite.com/2016/01/24/runtime%E4%B9%8BNSMutableDictionary%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>众所周知,apple要求我们在NSMutableDictionary中不能插入nil,所以我们一旦出现这种操作就会crash,但是我们不能保证完全不会出现这种操作,除非使用大量if去做参数合法性判断</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary * testDic = [[NSMutableDictionary alloc]init];</div><div class="line">[testDic setObject:nil forKey:@&quot;key&quot;];</div><div class="line">[testDic removeObjectForKey:nil];</div></pre></td></tr></table></figure>
<p><strong>比如以上两种情况,肯定毫不犹豫的就crash</strong><br><br><strong>注意:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testDic[&quot;key&quot;] = nil;</div></pre></td></tr></table></figure></p>
<p>是不会崩溃的,因为系统默认做了空值检查,推荐以后都用这种写法.</p>
<h5 id="我们现在要做的如果就是你一不小心出现以上操作-程序不会crash"><a href="#我们现在要做的如果就是你一不小心出现以上操作-程序不会crash" class="headerlink" title="我们现在要做的如果就是你一不小心出现以上操作,程序不会crash"></a>我们现在要做的如果就是你一不小心出现以上操作,程序不会crash</h5><p><strong>我们要用到这么几个方法</strong></p>
<font color="green"><br>//得到类的实例方法的实现 返回值为Method类型</font><br><strong>1、</strong> class_getInstanceMethod(Class cls, SEL name)<br><br><font color="green"> //得到类的类方法的实现 返回值为Method类型</font><br><strong>2、</strong> class_getClassMethod(Class cls, SEL name)<br><br><font color="green"> //交换方法m1 和方法m2的实现</font><br><strong>3、</strong> method_exchangeImplementations(Method m1, Method m2)<br><br><font color="green"> /*就像Application有生命周期回调方法一样,在Objective-C的类被加载和初始化的时候的回调方法,可以使用 Method Swizzing 以保证 Method Swizzing成功*/</font><br><strong>4、</strong> + (void)load<br>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>使用runtime <font color="red"> Method Swizzing </font>替换上述几个方法</li>
<li>让程序每次调用的以上几个方法之前,首先调用我们自定义的方法</li>
<li>在我们自定义的方法中校验参数合法性等,以保障之后调用系统的方法不会产生<font color="red">crash</font></li>
<li>执行完参数合法性判断之后,调用系统的方法,以达到预期调用目的</li>
</ol>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点 "></a><font color="red">要点 </font></h3><ol>
<li>在编译过程中NSMutableArray对象的Class 应该是<font color="red"><strong>__NSDictionaryM</strong> </font><small>(注意是双下划线)</small></li>
<li>必须保证在NSMutableArray这个对象初始化,或者使用之前已经完成<font color="red"> <strong>Method Swizzing</strong> </font>替换</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p> <strong>首先我们来完成前三步</strong></p>
<pre><code> -(void)customSetObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey{
    if (anObject) {
       [self customSetObject:anObject forKey:aKey];
    }else{
       NSLog(@&quot;setObject了一个空，key为%@&quot;,aKey);
   }
}
-(void)customRemoveObjectForKey:(id)aKey{
    if (aKey) {
        [self customRemoveObjectForKey:aKey];
    }else{
       NSLog(@&quot;remove了一个空，key为%@&quot;,aKey);
    }
}
</code></pre><p><strong>至此 用来替换系统方法的方法已经准备好了</strong><br><br><strong>然后我们要用自己的方法去替换系统的方法的实现</strong></p>
<pre><code>+(void)load{
    Class dictCls = NSClassFromString(@&quot;__NSDictionaryM&quot;);

    Method methodSetObjSuper = class_getInstanceMethod(dictCls, NSSelectorFromString(@&quot;setObject:forKey:&quot;));
    Method methodSetObj = class_getInstanceMethod(dictCls, @selector(customSetObject:forKey:));
    method_exchangeImplementations(methodSetObj, methodSetObjSuper);

    Method methodSuperRemoveKey = class_getInstanceMethod(dictCls, @selector(removeObjectForKey:));
    Method methodRemoveKey = class_getInstanceMethod(dictCls, @selector(customRemoveObjectForKey:));
    method_exchangeImplementations(methodRemoveKey, methodSuperRemoveKey);
}
</code></pre><p><strong>需要注意的是</strong> NSMutableDictionary在编译的时候是__NSDictionaryM类(双下划线)</p>
<h3 id="然后我们需要创建一个NSMutableDictionary的分类将代码放进去"><a href="#然后我们需要创建一个NSMutableDictionary的分类将代码放进去" class="headerlink" title="然后我们需要创建一个NSMutableDictionary的分类将代码放进去"></a>然后我们需要创建一个NSMutableDictionary的分类将代码放进去</h3><p><strong>比如</strong><br><img src="/img/NSMutableDictionary.png"><br>然后你就可以尝试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableDictionary * testDic = [[NSMutableDictionary alloc]init];</div><div class="line">[testDic setObject:nil forKey:@&quot;key&quot;];</div><div class="line">[testDic removeObjectForKey:nil];</div></pre></td></tr></table></figure></p>
<p>然后你就会发现程序并没有崩溃,其实原理非常简单.</p>
<ol>
<li>我们在程序开始运行的时候已经将系统的方法实现替换成自己的,同时也将自己的方法实现替换成系统的,所以如果想执行系统的方法,其实会先执行我们自定义的方法实现,我们在自己的方法实现中做参数合法性判断,如果不会引起系统崩溃那我们就去调用系统方法,会引起的话就不调用,所以肯定不会崩溃.</li>
</ol>
<h2 id="demo-https-github-com-OneHalfTooth-Runtime-Safe"><a href="#demo-https-github-com-OneHalfTooth-Runtime-Safe" class="headerlink" title="demo(https://github.com/OneHalfTooth/Runtime_Safe"></a><a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo(https://github.com/OneHalfTooth/Runtime_Safe</a></h2><p><strong>个人邮箱:mayang_email@sina.cn</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime之NSDictionary安全]]></title>
      <url>http://yoursite.com/2016/01/24/runtime%E4%B9%8BNSDictionary%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>昨天已经写文章探讨<a href="http://www.masyang.com/2016/01/23/runtime之NSMutableArray安全/" target="_blank" rel="external">runtime之NSDictionary安全</a>那么今天我们就来探讨一下怎样让NSDictionary安全,使NSDictionary操作nil而不crash<br><a id="more"></a></p>
<h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><p> 在NSDictionary中不管是key还是value是不能出现nil的,然而我们在做任何有关NSDictionary操作的时候我们都要考虑这个问题,参数会不会是nil,会不会引起崩溃.然后我们为了程序的健壮性,就写了一堆if,来校验参数合法性.来保证程序不会再运行的时候crash.<br> 现在我们用runtime,从根本上去预防NSDictionary插入nil崩溃这种问题<br><br> <strong>相对于NSMutableDictionary来说NSDictionary我们需要解决的问题就要少的多</strong><br><br>比如<font color="red"><strong>NSDictionary * test = @{@”crash”: nil, @”key”: @”value”};</strong></font><br><br><strong>在这只演示替换一个方法,如有更多需要请看<a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo:https://github.com/OneHalfTooth/Runtime_Safe</a></strong></p>
<h2 id="要使用的方法"><a href="#要使用的方法" class="headerlink" title="要使用的方法"></a>要使用的方法</h2><font color="green"><br>//得到类的实例方法的实现 返回值为Method类型</font><br><strong>1、</strong> class_getInstanceMethod(Class cls, SEL name)<br><br><font color="green"> //得到类的类方法的实现 返回值为Method类型</font><br><strong>2、</strong> class_getClassMethod(Class cls, SEL name)<br><br><font color="green"> //交换方法m1 和方法m2的实现</font><br><strong>3、</strong> method_exchangeImplementations(Method m1, Method m2)<br><br><font color="green"> /*就像Application有生命周期回调方法一样,在Objective-C的类被加载和初始化的时候的回调方法,可以使用 Method Swizzing 以保证 Method Swizzing成功*/</font><br><strong>4、</strong> + (void)load<br>

<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><ol>
<li>使用自定义的方法,将系统的方法替换掉</li>
<li>在自定义方法中做参数合法性判断</li>
<li>调用系统的方法以达到预期目的</li>
<li>交换自定义方法与系统方法的实现</li>
</ol>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ol>
<li>实现解决思路的前三步<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+(instancetype)customDictionaryWithObjects:(const id [])objects forKeys:(const id &lt;NSCopying&gt; [])keys count:(NSUInteger)cnt &#123;</div><div class="line">	id nObjects[cnt];</div><div class="line">	id nKeys[cnt];</div><div class="line">	int i=0, j=0;</div><div class="line">	for (; i&lt;cnt &amp;&amp; j&lt;cnt; i++) &#123;</div><div class="line">		if (objects[i] &amp;&amp; keys[i]) &#123;</div><div class="line">			nObjects[j] = objects[i];</div><div class="line">			nKeys[j] = keys[i];</div><div class="line">			j++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return [self customDictionaryWithObjects:nObjects forKeys:nKeys count:j];//调用系统的方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>对objects进行空值过滤，如果是空值的话，不插入字典。达到参数合法性判断的目的</strong></p>
<ol>
<li>替换系统的方法</li>
</ol>
<pre><code>+(void)load{
    Method originalMethod = class_getClassMethod(self, @selector(dictionaryWithObjects:forKeys:count:));
    Method swizzledMethod = class_getClassMethod(self, @selector(customDictionaryWithObjects:forKeys:count:));
    method_exchangeImplementations(originalMethod, swizzledMethod);
}
</code></pre><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ol>
<li><p><strong>为什么我们要在load中执行Method Swizzing</strong><br><br> 因为这个方法会在类初始化之前执行,这样我们就可以保证系统方法的实现已经被我们替换</p>
</li>
<li><p><strong>以上代码中出现自己调用自己的死循环</strong><br> 如果你细心肯定会发现上边自定义方法里边出现了自己调用自己的情况,但是我在后边的注释确是//调用系统的方法. 正常的说,这种情况应该是一个死循环,但是你不要忘了现在我们使用了Method Swizzing,我们已经用runtime 将自定义方法的方法的实现与系统的实现交换 我们交换的只是实现,只是方法名还是没有变</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime之NSMutableArray安全]]></title>
      <url>http://yoursite.com/2016/01/23/runtime%E4%B9%8BNSMutableArray%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>昨天的<strong><a href="http://www.masyang.com/2016/01/22/runtime之NSArray、NSDictionary安全/" target="_blank" rel="external">博文:runtime之NSArray安全</a></strong>已经介绍了有关通过<font color="red"> Swizzing </font>使NSArray安全的操作,那么今天我们来谈一下相对繁琐的使用Swizzing让NSMutableArray安全的操作.<small>PS:文笔不行,望海涵</small></p>
   <a id="more"></a>  
<p><strong><a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo地址 : https://github.com/OneHalfTooth/Runtime_Safe</a></strong></p>
<h2 id="用到的方法"><a href="#用到的方法" class="headerlink" title="用到的方法"></a>用到的方法</h2><font color="green"><br>//得到类的实例方法的实现 返回值为Method类型</font><br><strong>1、</strong> class_getInstanceMethod(Class cls, SEL name)<br><br><font color="green"> //得到类的类方法的实现 返回值为Method类型</font><br><strong>2、</strong> class_getClassMethod(Class cls, SEL name)<br><br><font color="green"> //交换方法m1 和方法m2的实现</font><br><strong>3、</strong> method_exchangeImplementations(Method m1, Method m2)<br><br><font color="green"> /*就像Application有生命周期回调方法一样,在Objective-C的类被加载和初始化的时候的回调方法,可以使用 Method Swizzing 以保证 Method Swizzing成功*/</font><br><strong>4、</strong> + (void)load<br>

<h2 id="要解决的痛点"><a href="#要解决的痛点" class="headerlink" title="要解决的痛点"></a>要解决的痛点</h2><p><strong>NSMutableArray * array = [[NSMutableArray alloc]init];</strong></p>
<p><font color="green">/* array追加一个nil对象*/</font><br><strong>1.</strong> [array addObject:nil];</p>
<p><font color="green">/* array追加一个nil的数组*/</font><br><strong>2.</strong> [array addObjectsFromArray:nil];</p>
<p><font color="green">/* array插入一个nil*/</font><br><strong>3.</strong> [array insertObject:nil atIndex:0];</p>
<p><font color="green">/* 在array大于array.count 位置插入一个对象*/</font><br><strong>4.</strong> [array insertObject:@”key” atIndex:9999];</p>
<p><font color="green">/* array移除一个nil的对象*/</font><br><strong>5.</strong> [array removeObject:nil];</p>
<p><font color="green">/* 移除array大于array.count 位置的对象*/</font><br><strong>6.</strong> [array removeObjectAtIndex:9999];</p>
<p><strong>以上情况基本都能导致应用crash,现在我们就来彻底解决这种crash</strong></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>使用runtime <font color="red"> Method Swizzing </font>替换上述几个方法</li>
<li>让程序每次调用的以上几个方法之前,首先调用我们自定义的方法</li>
<li>在我们自定义的方法中校验参数合法性等,以保障之后调用系统的方法不会产生<font color="red">crash</font></li>
<li>执行完参数合法性判断之后,调用系统的方法,以达到预期调用目的</li>
</ol>
<h5 id="要点"><a href="#要点" class="headerlink" title="要点 "></a><font color="red">要点 </font></h5><ol>
<li>在编译过程中NSMutableArray对象的Class 应该是<font color="red"><strong>__NSArrayM</strong> </font><small>(注意是双下划线)</small></li>
<li>必须保证在NSMutableArray这个对象初始化,或者使用之前已经完成<font color="red"> <strong>Method Swizzing</strong> </font>替换</li>
<li>arr[0] = @”value” 和 [array addObject:@”value”] 或者 [array insertObject:@”value” atIndex:0]<font color="red"><strong>调用的系统方法是不同的</strong></font>.</li>
</ol>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="一、使用Method-Swizzing替换上述几个方法"><a href="#一、使用Method-Swizzing替换上述几个方法" class="headerlink" title="一、使用Method Swizzing替换上述几个方法"></a><small>一、使用<font color="red">Method Swizzing</font>替换上述几个方法</small></h6><p>自定义上述的几个方法,用来替换系统的几个方法<small>(要求:参数类型,返回值最好保持一致)<font color="red">看完这几个方法,可能有些许疑惑,稍后为你解答</font></small>.</p>
<pre><code>//用来替换removeObject:方法
-(void)customRemoveObject:(id)anObject{
    if (anObject) {/*参数合法性判断*/
        //调用系统的RemoveObject:方法
        [self customRemoveObject:anObject];
    }else{
        NSLog(@&quot;数组移除了一个nil的元素&quot;);
    }
}
//替换removeObjectAtIndex:方法
-(void)customRemoveObjectAtIndex:(NSUInteger)index{
    if (index &lt; self.count) {/*参数合法性判断*/
        //调用系统的RemoveObjectAtIndex:方法
        [self customRemoveObjectAtIndex:index];
    }else{
        NSLog(@&quot;数组越界操作,下标为%lu&quot;,index);
    }
}
//用来替换同类的 arr[0] = @&quot;value&quot;这种写法
-(void)msySetObject:(id)obj atIndexedSubscript:(NSUInteger)idx{
    if (obj) {/*参数合法性判断*/
        //调用系统的setObject:atIndexedSubscript:方法
        [self msySetObject:obj atIndexedSubscript:idx];
    }else{
        NSLog(@&quot;数组赋值为nil：%s传了个空值\n&quot;,__func__);
    }
}
- (void)msyInsertObject:(id)anObject atIndex:(NSUInteger)index{
    if (anObject &amp;&amp; index &lt;= self.count) {/*参数合法性判断*/
        //调用系统的insertObject:atIndex:方法
        [self msyInsertObject:anObject atIndex:index];
    }else{
        NSLog(@&quot;数组赋值为nil：%s传了个空值\n&quot;,__func__);
    }
}
- (void)msyAddObject:(id)obj{
    if (obj) {/*参数合法性判断*/
    //调用系统的ObjectAtIndex:方法
        [self msyAddObject:obj];
    }else{
        NSLog(@&quot;数组赋值为nil：%s传了个空值\n&quot;,__func__);
    }
}
- (id)custmeObjectAtIndex:(NSInteger)index{
    if (index &gt;= self.count) {/*参数合法性判断*/
        return nil;
    }
    //调用系统的ObjectAtIndex:方法
    return [self custmeObjectAtIndex:index];
}
</code></pre><p><strong>至此 用来替换系统方法的方法已经准备好了</strong><br><br><strong>然后我们要用自己的方法去替换系统的方法的实现</strong></p>
<pre><code>//必须包含运行时的库
#import &lt;objc/runtime.h&gt;

//在load方法里边交换自定义方法与系统方法的实现,
//因为这个方法会在类初始化之前执行,这样我们就可以保证系统方法的实现已经被我们替换
+(void)load{

//先获取NSMutableArray的Class @&quot;__NSArrayM&quot; 为双下划线
Class arrayM = NSClassFromString(@&quot;__NSArrayM&quot;);

//获取实例方法addObject:的Method
Method methodSuper = class_getInstanceMethod(arrayM, @selector(addObject:));
//获取自己定义的实例方法msyAddObject:的Method
Method method = class_getInstanceMethod(arrayM, @selector(msyAddObject:));
//交换两个方法的实现
method_exchangeImplementations(methodSuper, method);

//一下注释同上
Method methodSuperInsert = class_getInstanceMethod(arrayM, @selector(insertObject:atIndex:));
Method methodInsert = class_getInstanceMethod(arrayM, @selector(msyInsertObject:atIndex:));
method_exchangeImplementations(methodSuperInsert, methodInsert);

Method methodSuperSetObj = class_getInstanceMethod(arrayM, @selector(setObject:atIndexedSubscript:));
Method methodSetObj = class_getInstanceMethod(arrayM, @selector(msySetObject:atIndexedSubscript:));
method_exchangeImplementations(methodSetObj, methodSuperSetObj);

Method methodSuperRemove = class_getInstanceMethod(arrayM, @selector(removeObjectAtIndex:));
Method methodRemove = class_getInstanceMethod(arrayM, @selector(customRemoveObjectAtIndex:));
method_exchangeImplementations(methodSuperRemove, methodRemove);

Method methodSuperRemoveObj = class_getInstanceMethod(arrayM, @selector(removeObject:));
Method methodRemoveObj = class_getInstanceMethod(arrayM, @selector(customRemoveObject:));
method_exchangeImplementations(methodSuperRemoveObj, methodRemoveObj);

Method objectAtIndex = class_getInstanceMethod(arrayM, @selector(objectAtIndex:));
Method customeObjectAtIndex = class_getInstanceMethod(arrayM, @selector(custmeObjectAtIndex:));
method_exchangeImplementations(objectAtIndex, customeObjectAtIndex);
</code></pre><p>}</p>
<h6 id="二、创建一个NSMutableArray-的分类-将上述代码放入"><a href="#二、创建一个NSMutableArray-的分类-将上述代码放入" class="headerlink" title="二、创建一个NSMutableArray 的分类,将上述代码放入"></a><small>二、创建一个NSMutableArray 的分类,将上述代码放入</small></h6><p><img src="/img/NSMutableArraySafeImage.png"><br>😆😆😆😆😆😆<br><br>然后你就可以愉快的这样了</p>
<pre><code>NSMutableArray * array = [[NSMutableArray alloc]init];
[array addObject:nil];
[array addObjectsFromArray:nil];
[array insertObject:nil atIndex:0];
[array insertObject:@&quot;value&quot; atIndex:9999];
[array insertObjects:nil atIndexes:0];
[array removeObject:nil];
[array removeObjectAtIndex:9999];
[array removeObjectsInArray:nil];
</code></pre><p>并且你会神奇的发现他没有crash</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><ol>
<li><strong>上述代码中出现了自己调用自己</strong></li>
</ol>
<pre><code>-(void)msyAddObject:(id)obj{
        if (obj) {/*参数合法性判断*/
          [self msyAddObject:obj];//调用系统的addObject:方法
      }else{
           NSLog(@&quot;数组赋值为nil：%s传了个空值\n&quot;,__func__);
      }
 }
</code></pre><p><small>如果你细心肯定会发现第3行代码出现了自己调用自己的情况,但是我在后边的注释确是<font color="green">//调用系统的addObject:方法</font>.<br>正常的说,这种情况应该是一个死循环,但是你不要忘了现在我们使用了Method Swizzing,我们已经用runtime 将<font color="red">msyAddObject:方法的方法的<big><strong>实现</strong></big>与addObject:的<strong><big>实现</big></strong>交换</font><br>我们交换的只是实现,只是方法名还是没有变,所以写在msyAddObject:的代码,经过我们的<font color="red">method_exchangeImplementations(Method m1,Method m2)</font>之后已经不是写在msyAddObject:里边,而是在系统的addObject:中,所以我们在msyAddObject:调用msyAddObject:的时候,其实是调用系统addObject:的实现,所以并不是自己调用自己😄,也就不会出现死循环了</small></p>
<ol>
<li><strong>或许你发现本人在创建分类的时候出现了一个#ifdef DEBUG #else #endif</strong></li>
</ol>
<p><small>这是条件编译,表示在debug模式下 会编译#ifdef 和 #else之间的代码,在release模式会编译#else #endif之间的代码,这样做的目的是为了在编写代码的时候能够尽多的发现问题,而在上线的时候尽多的避免问题</small></p>
<h2 id="表达能力很差-可能有些东西没说清楚-如有需要可以深入沟通"><a href="#表达能力很差-可能有些东西没说清楚-如有需要可以深入沟通" class="headerlink" title="表达能力很差,可能有些东西没说清楚,如有需要可以深入沟通."></a>表达能力很差,可能有些东西没说清楚,如有需要可以深入沟通.</h2><p><strong><a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo地址 : https://github.com/OneHalfTooth/Runtime_Safe</a></strong><br><br><strong>个人邮箱:mayang_email@sina.cn</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime之NSArray安全]]></title>
      <url>http://yoursite.com/2016/01/22/runtime%E4%B9%8BNSArray%E3%80%81NSDictionary%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>看了<a href="http://www.cnblogs.com/muyushifang07/p/5737564.html" target="_blank" rel="external"><strong>沐雨十方07</strong></a>的这篇博客之后，我决定将自己开发过程中用的一个小技巧分享一下,以方便各种猿的程序开发。</p>
   <a id="more"></a>  
<p>众所周知，在apple的淫威下NSArray,NSDictionary,NSMutableArray,NSMutableDictionary是不不能出现有关nil的操作,一旦操作就会出现<strong>crash</strong>的后果,如果我们要避免这种<strong>crash</strong>那么就要增加许多if,现在我们来利用runtime彻底解决这个问题.<br><br><br><a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">demo地址 : https://github.com/OneHalfTooth/Runtime_Safe</a></p>
<p><strong>首先我们可能用到几个函数</strong>（需要包含<font color="red">运行时库</font>）<br><br> <font color="red">class_getInstanceMethod(Class cls, SEL name):得到类的实例方法</font></p>
  <font color="red">class_getClassMethod(Class cls, SEL name):得到类的类方法</font>

<p>  <font color="red"> method_exchangeImplementations(Method m1, Method m2) : 交换方法m1 和方法m2的实现</font></p>
<h2 id="runtime之NSArray的nil操作"><a href="#runtime之NSArray的nil操作" class="headerlink" title="runtime之NSArray的nil操作"></a>runtime之NSArray的nil操作</h2><p>码代码的过程中我们一不小心可能就会出现类似于这种情况</p>
<pre><code>NSArray * temp = @[@&quot;0&quot;,@&quot;1&quot;,@&quot;2&quot;];
NSString * str = [temp objectAtIndex:4];
</code></pre><p>后果就是<strong>crash</strong><br><br>但是我们发现大牛们写代码的时候通常<strong>很少出现对数组越界</strong>的异常处理情况,到底是什么原因呢，其实我也不知道😝<br><br>而我是使用runtime的黑魔法来解决这种情况的,请看源码<br></p>
<pre><code>- (id)custmeObjectAtIndex:(NSInteger)index{
if (index &gt;= self.count) {
    return nil;
}
//或许你对这里有个疑问，稍后解答
return [self custmeObjectAtIndex:index];
}
</code></pre><p>首先我声明一个方法,因为我要用黑魔法<font color="red">（Method Swizzling）</font>将系统的<strong>objectAtIndex:</strong>方法实现给替换掉,这样做的目的是在<strong>NSArray调用objectAtIndex:</strong>方法的时候，首先调用<strong>(custmeObjectAtIndex:)</strong>本人定义好的方法,然后在custmeObjectAtIndex:这个方法中去判断参数合法性，再做下一步打算.<br><br>然后我们开始使用<font color="red">（Method Swizzling）</font>将系统<strong>objectAtIndex:</strong>的实现和<strong>(custmeObjectAtIndex:)</strong>的实现进行交换</p>
<pre><code>//NSArray 在编译的时候名字并不是NSarray而是__NSArray0
Class arrayM = NSClassFromString(@&quot;__NSArray0&quot;);

//获取到系统objectAtIndex:
Method objectAtIndex = class_getInstanceMethod(arrayM, @selector(objectAtIndex:));

//获取自定义的custmeObjectAtIndex:
Method customeObjectAtIndex = class_getInstanceMethod(arrayM, @selector(custmeObjectAtIndex:));

//交换两个方法的实现
method_exchangeImplementations(objectAtIndex, customeObjectAtIndex);
</code></pre><p>至此,我们常见的数组越界crash已经被解决了,但是你是不是已经蒙圈了😁,为什么在<strong>- (id)custmeObjectAtIndex:(NSInteger)index</strong>方法中出现了 <strong>[self custmeObjectAtIndex:index];</strong>自己调用自己这种情况呢,前边我已经说了是交换两个方法的实现,所以说两个方法的内容<strong>(简单的说就是方法里边的代码)</strong>已经被交换,所以[self custmeObjectAtIndex:index]这句代码调用的系统objectAtIndex:的实现，所以并不是自己调用自己</p>
<p><strong>我们还需要注意一点,我们必须保证任何时间,只要是有关NSArray的操作,我们的runtime已经执行过了<br>所以我们要在+ (void)load方法去执行这个Swizzing</strong></p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import &lt;objc/runtime.h&gt;

//分类
@implementation NSArray (Safe)
//初始化的时候会被执行一次
+ (void)load {

Method originalMethod = class_getClassMethod(self, @selector(arrayWithObjects:count:));
Method swizzledMethod = class_getClassMethod(self, @selector(customArrayWithObjects:count:));
method_exchangeImplementations(originalMethod, swizzledMethod);

Class arrayM = NSClassFromString(@&quot;__NSArray0&quot;);
Method objectAtIndex = class_getInstanceMethod(arrayM, @selector(objectAtIndex:));
Method customeObjectAtIndex = class_getInstanceMethod(arrayM, @selector(custmeObjectAtIndex:));
method_exchangeImplementations(objectAtIndex, customeObjectAtIndex);

}


+ (instancetype)customArrayWithObjects:(const id [])objects count:(NSUInteger)cnt {

    id nObjects[cnt];
    int i=0, j=0;
    for (; i&lt;cnt &amp;&amp; j&lt;cnt; i++) {
        if (objects[i]) {
            nObjects[j] = objects[i];
            j++;
        }
    }
    return [self customArrayWithObjects:nObjects count:j];
}

- (id)custmeObjectAtIndex:(NSInteger)index{

    if (index &gt;= self.count) {
        return nil;
    }
return [self custmeObjectAtIndex:index];
}
</code></pre><p><strong>至此一个关于NSArray的安全类已经结束,当然这只是一部分,更详细请<a href="https://github.com/OneHalfTooth/Runtime_Safe" target="_blank" rel="external">查看demo:https://github.com/OneHalfTooth/Runtime_Safe</a></strong><br><br><strong>欢迎提出您的宝贵意见:<font color="blue">mayang_email@sina.cn</font></strong></p>
]]></content>
    </entry>
    
  
  
</search>
